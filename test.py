# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
from shutil import copyfile
import pandas as pd
import numpy as np
from PyQt5 import QtGui, QtWidgets
from PyQt5.QtCore import Qt, QRegExp
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QCursor, QPixmap, QRegExpValidator, QIcon
from PyQt5.QtWidgets import QWidget, QFileDialog, QMenu, QMessageBox, QListWidgetItem, QLabel, QHBoxLayout, \
    QProgressBar, QAction, QToolButton, QStyleFactory, QApplication
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_auc_score, roc_curve, auc
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB, MultinomialNB, BernoulliNB
from sklearn import tree, svm
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.model_selection import GridSearchCV
from sklearn.decomposition import PCA, KernelPCA, IncrementalPCA
from imblearn.over_sampling import RandomOverSampler, SMOTE, ADASYN
from imblearn.under_sampling import RandomUnderSampler, ClusterCentroids, TomekLinks
import seaborn as sns
import joblib

import matplotlib

matplotlib.use("Qt5Agg")  # 声明使用QT5
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt

from icon.resource import *


class Ui_widget(QWidget):
    def __init__(self, w=1800, h=1200):
        """
        窗口初始化
        :param w: 窗口宽
        :param h: 窗口高
        """
        super().__init__()
        self.resize(w, h)
        self.setupUi(self)
        self.setWindowTitle('机器学习工具箱')
        icon = QIcon("./icon/机器学习.png")
        self.setWindowIcon(icon)
        QApplication.setStyle(QStyleFactory.create('Windows'))  #['Windows', 'WindowsXP', 'Fusion']

        # 是否已经导入数据
        self.load_data_flag = False
        # 数据是否不含有字符
        self.str_flag = True
        # 进行特征选择时是否先进行了特征分析
        self.fea_analyzed_flag = False
        # 进行PCA时是否先进行了PCA分析
        self.pca_analyzed_flag = False

        # 数据载入时训练集和测试集的分割比
        self.load_data_split_rate = 0.6
        # 选择哪些名称的数据进行编码
        self.code_name_index_lists = []
        self.code_name_lists = []
        self.code_categorical_lists = []
        self.code_mode_lists = []
        # 均衡化具体是哪一种
        self.equal_index = 0
        # 预处理表格中的数据是否可以保存，且保存哪一个
        self.process_table_flag = 0
        # PCA相关参数
        self.PCA_parameter_stack.setCurrentIndex(0)
        self.pca_whiten_select = True
        self.pca_svd_select = 'auto'
        self.kpca_kernel_select = 'linear'
        self.ipca_whiten_select = True
        # 选择模型相关的list
        self.model_name_list = ['Logist', 'Knn', 'Tree', 'Bayes', 'SVM', 'Forest']
        self.model_img_path = ["./model_img/logist.png", "./model_img/KNN.png", "./model_img/tree.png",
                               "./model_img/Naive Bayes.png", "./model_img/SVM.png", "./model_img/forest.png"]
        # 模型参数保存相关的list
        self.model_code_name_lists = []
        self.model_code_categorical_lists = []
        self.model_code_mode_lists = []
        self.item_list = []
        self.model_process_lists = []
        self.x_train_list = []
        self.x_test_list = []
        self.y_train_list = []
        self.y_test_list = []
        self.model_para_list = []
        self.trained_model_list = []
        self.model_check_list = []
        # 逻辑回归相关参数
        self.lr_penalty_select = 'l1'
        self.lr_solver_select = 'liblinear'
        # knn相关参数
        self.knn_weights_select = 'uniform'
        self.knn_p_select = 1
        # tree相关参数
        self.tree_criterion_select = 'gini'
        self.tree_depth_select = 3
        self.tree_splitter_select = 'best'
        # svm相关参数
        self.svm_kernel_select = 'rbf'
        # 模型评估相关变量
        self.assess_page_total = 1
        self.assess_page_now = 0
        self.assess_graphic_list = [None, None]

        # 槽函数连接
        self.control_connect()

    def setupUi(self, widget):
        """
        控件初始化
        :param widget:
        :return:
        """
        # 总布局
        self.widget_layout = QtWidgets.QVBoxLayout(widget)
        self.widget_layout.setContentsMargins(0, 0, 0, 0)
        self.widget_layout.setSpacing(3)
        # 顶部功能布局
        self.top_meun_layout = QtWidgets.QHBoxLayout()
        self.top_meun_layout.setSpacing(3)
        # 顶部功能的加载数据区布局
        self.load_menu_layout = QtWidgets.QVBoxLayout()
        self.load_menu_layout.setSpacing(0)
        # 顶部功能的加载数据区的加载按钮
        self.load_data_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.load_data_but.sizePolicy().hasHeightForWidth())
        self.load_data_but.setSizePolicy(sizePolicy)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(":/icon/file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.load_data_but.setIcon(icon)
        self.load_data_but.setIconSize(QtCore.QSize(32, 32))
        self.load_data_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.load_data_but.setAutoRaise(True)
        self.load_menu_layout.addWidget(self.load_data_but)
        # 加载数据区的label
        self.load_menu_label = QtWidgets.QLabel(widget)
        self.load_menu_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignHCenter)
        self.load_menu_layout.addWidget(self.load_menu_label)
        # 设置加载数据区的控件占比
        self.load_menu_layout.setStretch(0, 3)
        self.load_menu_layout.setStretch(1, 1)
        # 将加载数据区布局添加到顶部功能布局中
        self.top_meun_layout.addLayout(self.load_menu_layout)
        # 数据区与预处理区的line
        self.top_line1 = QtWidgets.QFrame(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.top_line1.sizePolicy().hasHeightForWidth())
        self.top_line1.setSizePolicy(sizePolicy)
        self.top_line1.setFrameShadow(QtWidgets.QFrame.Raised)
        self.top_line1.setLineWidth(2)
        self.top_line1.setFrameShape(QtWidgets.QFrame.VLine)
        self.top_meun_layout.addWidget(self.top_line1)
        # 顶部功能的预处理区布局
        self.process_menu_layout = QtWidgets.QVBoxLayout()
        self.process_menu_layout.setSpacing(0)
        # 顶部功能的预处理区按钮布局
        self.process_menu_but_layout = QtWidgets.QHBoxLayout()
        self.process_menu_but_layout.setSpacing(0)
        # 特征选择按钮
        self.select_feature_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.select_feature_but.sizePolicy().hasHeightForWidth())
        self.select_feature_but.setSizePolicy(sizePolicy)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(":/icon/特征选择.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.select_feature_but.setIcon(icon1)
        self.select_feature_but.setIconSize(QtCore.QSize(25, 25))
        self.select_feature_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.select_feature_but.setAutoRaise(True)
        self.process_menu_but_layout.addWidget(self.select_feature_but)
        # PCA按钮
        self.PCA_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.PCA_but.sizePolicy().hasHeightForWidth())
        self.PCA_but.setSizePolicy(sizePolicy)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(":/icon/pca-选中.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.PCA_but.setIcon(icon2)
        self.PCA_but.setIconSize(QtCore.QSize(25, 25))
        self.PCA_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.PCA_but.setAutoRaise(True)
        self.process_menu_but_layout.addWidget(self.PCA_but)
        # 标准化按钮
        self.equal_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.equal_but.sizePolicy().hasHeightForWidth())
        self.equal_but.setSizePolicy(sizePolicy)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(":/icon/数据归一化.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.equal_but.setIcon(icon3)
        self.equal_but.setIconSize(QtCore.QSize(25, 25))
        self.equal_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.equal_but.setAutoRaise(True)
        self.process_menu_but_layout.addWidget(self.equal_but)
        # 编码按钮
        self.encode_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.encode_but.sizePolicy().hasHeightForWidth())
        self.encode_but.setSizePolicy(sizePolicy)
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(":/icon/独热编码.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.encode_but.setIcon(icon4)
        self.encode_but.setIconSize(QtCore.QSize(42, 44))
        self.encode_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.encode_but.setAutoRaise(True)
        self.process_menu_but_layout.addWidget(self.encode_but)
        self.process_menu_layout.addLayout(self.process_menu_but_layout)
        # 预处理区的label
        self.process_menu_label = QtWidgets.QLabel(widget)
        self.process_menu_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignHCenter)
        self.process_menu_layout.addWidget(self.process_menu_label)
        # 设置预处理区控件占比
        self.process_menu_layout.setStretch(0, 3)
        self.process_menu_layout.setStretch(1, 1)
        # 将预处理区布局添加到顶部功能布局中
        self.top_meun_layout.addLayout(self.process_menu_layout)
        # 预处理区与模型训练区的line
        self.top_line2 = QtWidgets.QFrame(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.top_line2.sizePolicy().hasHeightForWidth())
        self.top_line2.setSizePolicy(sizePolicy)
        self.top_line2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.top_line2.setLineWidth(2)
        self.top_line2.setFrameShape(QtWidgets.QFrame.VLine)
        self.top_meun_layout.addWidget(self.top_line2)
        # 顶部功能的模型训练区布局
        self.model_train_menu_layout = QtWidgets.QVBoxLayout()
        self.model_train_menu_layout.setSpacing(0)
        # 顶部功能的模型训练区的按钮布局
        self.model_train_menu_totall_layout = QtWidgets.QHBoxLayout()
        self.model_train_menu_totall_layout.setSpacing(0)
        # 模型选择combobox
        self.model_select_combobox = QtWidgets.QComboBox(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_select_combobox.sizePolicy().hasHeightForWidth())
        self.model_select_combobox.setSizePolicy(sizePolicy)
        self.model_train_menu_totall_layout.addWidget(self.model_select_combobox)
        # 模型训练菜单布局
        self.model_train_menu_but_layout = QtWidgets.QVBoxLayout()
        self.model_train_menu_but_layout.setSpacing(0)
        # 训练当前模型按钮
        self.model_start_now_but = QtWidgets.QPushButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_start_now_but.sizePolicy().hasHeightForWidth())
        self.model_start_now_but.setSizePolicy(sizePolicy)
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(":/icon/开始.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.model_start_now_but.setIcon(icon5)
        self.model_start_now_but.setFlat(True)
        self.model_train_menu_but_layout.addWidget(self.model_start_now_but)
        # 开始所有训练按钮
        self.model_start_all_but = QtWidgets.QPushButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_start_all_but.sizePolicy().hasHeightForWidth())
        self.model_start_all_but.setSizePolicy(sizePolicy)
        icon6 = QtGui.QIcon()
        icon6.addPixmap(QtGui.QPixmap(":/icon/开始所有轮询.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.model_start_all_but.setIcon(icon6)
        self.model_start_all_but.setFlat(True)
        self.model_train_menu_but_layout.addWidget(self.model_start_all_but)
        # 删除模型按钮
        self.delete_model_but = QtWidgets.QPushButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.delete_model_but.sizePolicy().hasHeightForWidth())
        self.delete_model_but.setSizePolicy(sizePolicy)
        icon7 = QtGui.QIcon()
        icon7.addPixmap(QtGui.QPixmap(":/icon/删除.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.delete_model_but.setIcon(icon7)
        self.delete_model_but.setFlat(True)
        self.model_train_menu_but_layout.addWidget(self.delete_model_but)
        # 将模型训练菜单布局添加到模型训练区的按钮布局中
        self.model_train_menu_totall_layout.addLayout(self.model_train_menu_but_layout)
        # 模型训练区的按钮布局控件占比
        self.model_train_menu_totall_layout.setStretch(0, 2)
        self.model_train_menu_totall_layout.setStretch(1, 1)
        # 将模型训练区的按钮布局添加到模型训练布局中
        self.model_train_menu_layout.addLayout(self.model_train_menu_totall_layout)
        # 模型训练区的label
        self.model_train_menu_label = QtWidgets.QLabel(widget)
        self.model_train_menu_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignHCenter)
        self.model_train_menu_layout.addWidget(self.model_train_menu_label)
        # 模型训练区的控件占比
        self.model_train_menu_layout.setStretch(0, 3)
        self.model_train_menu_layout.setStretch(1, 1)
        # 将模型训练区布局添加到顶部功能布局中
        self.top_meun_layout.addLayout(self.model_train_menu_layout)
        # 模型训练与模型评估的line
        self.top_line3 = QtWidgets.QFrame(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.top_line3.sizePolicy().hasHeightForWidth())
        self.top_line3.setSizePolicy(sizePolicy)
        self.top_line3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.top_line3.setLineWidth(2)
        self.top_line3.setFrameShape(QtWidgets.QFrame.VLine)
        self.top_meun_layout.addWidget(self.top_line3)
        # 顶部功能的模型评估区布局
        self.model_assess_menu_layout = QtWidgets.QVBoxLayout()
        # 顶部功能的模型评估区按钮布局
        self.model_assess_menu_but_layout = QtWidgets.QHBoxLayout()
        self.model_assess_menu_but_layout.setSpacing(0)
        # 模型预测按钮
        self.model_predict_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_predict_but.sizePolicy().hasHeightForWidth())
        self.model_predict_but.setSizePolicy(sizePolicy)
        icon8 = QtGui.QIcon()
        icon8.addPixmap(QtGui.QPixmap(":/icon/模型预测.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.model_predict_but.setIcon(icon8)
        self.model_predict_but.setIconSize(QtCore.QSize(25, 25))
        self.model_predict_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.model_predict_but.setAutoRaise(True)
        self.model_assess_menu_but_layout.addWidget(self.model_predict_but)
        # 模型评估按钮
        self.model_assess_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_assess_but.sizePolicy().hasHeightForWidth())
        self.model_assess_but.setSizePolicy(sizePolicy)
        icon9 = QtGui.QIcon()
        icon9.addPixmap(QtGui.QPixmap(":/icon/分类模型评估.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.model_assess_but.setIcon(icon9)
        self.model_assess_but.setIconSize(QtCore.QSize(25, 25))
        self.model_assess_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.model_assess_but.setAutoRaise(True)
        self.assess_menu = QMenu()
        self.confusion_matrix_action = QAction("混淆矩阵", self.assess_menu)
        self.confusion_matrix_action.setData('confusion_matrix')
        self.assess_menu.addAction(self.confusion_matrix_action)
        # self.confusion_matrix_action.triggered.connect(self.confusion_matrix_action_handle)
        self.AUC_action = QAction("ROC曲线", self.assess_menu)
        self.AUC_action.setData('AUC')
        self.assess_menu.addAction(self.AUC_action)
        self.model_assess_but.setMenu(self.assess_menu)
        self.model_assess_but.setPopupMode(QToolButton.InstantPopup)
        self.model_assess_menu_but_layout.addWidget(self.model_assess_but)
        # 导出模型按钮
        self.model_export_but = QtWidgets.QToolButton(widget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_export_but.sizePolicy().hasHeightForWidth())
        self.model_export_but.setSizePolicy(sizePolicy)
        icon10 = QtGui.QIcon()
        icon10.addPixmap(QtGui.QPixmap(":/icon/导出.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.model_export_but.setIcon(icon10)
        self.model_export_but.setIconSize(QtCore.QSize(25, 25))
        self.model_export_but.setToolButtonStyle(QtCore.Qt.ToolButtonTextUnderIcon)
        self.model_export_but.setAutoRaise(True)
        self.model_assess_menu_but_layout.addWidget(self.model_export_but)
        self.model_assess_menu_layout.addLayout(self.model_assess_menu_but_layout)
        # 顶部模型评估区的label
        self.model_assess_menu_label = QtWidgets.QLabel(widget)
        self.model_assess_menu_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignHCenter)
        self.model_assess_menu_layout.addWidget(self.model_assess_menu_label)
        # 模型评估区的控件占比
        self.model_assess_menu_layout.setStretch(0, 3)
        self.model_assess_menu_layout.setStretch(1, 1)
        # 将模型评估区布局添加到顶部功能布局中
        self.top_meun_layout.addLayout(self.model_assess_menu_layout)
        # 顶部功能区的各个区域占比
        self.top_meun_layout.setStretch(0, 1)
        self.top_meun_layout.setStretch(2, 2)
        self.top_meun_layout.setStretch(4, 3)
        self.top_meun_layout.setStretch(6, 2)
        # 将顶部功能布局添加到总布局中
        self.widget_layout.addLayout(self.top_meun_layout)
        # 顶部功能区与下方stack的line
        self.split_line = QtWidgets.QFrame(widget)
        self.split_line.setFrameShadow(QtWidgets.QFrame.Raised)
        self.split_line.setLineWidth(2)
        self.split_line.setFrameShape(QtWidgets.QFrame.HLine)
        self.widget_layout.addWidget(self.split_line)
        # 底部总stack
        self.total_stack = QtWidgets.QStackedWidget(widget)
        # 加载数据page及布局
        self.load_data_page = QtWidgets.QWidget()
        self.load_data_page_layout = QtWidgets.QVBoxLayout(self.load_data_page)
        self.load_data_page_layout.setContentsMargins(0, 0, 0, 0)
        self.load_data_page_layout.setSpacing(3)
        # 加载数据page的按钮布局
        self.load_data_page_but_layout = QtWidgets.QHBoxLayout()
        self.load_data_page_but_layout.setSpacing(10)
        # 加载数据page的模型大类选择label
        self.load_data_select_model_label = QtWidgets.QLabel(self.load_data_page)
        self.load_data_select_model_label.setAlignment(
            QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.load_data_page_but_layout.addWidget(self.load_data_select_model_label)
        # 加载数据page的模型大类选择combobox
        self.load_data_select_model_combobox = QtWidgets.QComboBox(self.load_data_page)
        self.load_data_page_but_layout.addWidget(self.load_data_select_model_combobox)
        # 加载数据page的标签选择label
        self.load_data_select_target_label = QtWidgets.QLabel(self.load_data_page)
        self.load_data_select_target_label.setAlignment(
            QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.load_data_page_but_layout.addWidget(self.load_data_select_target_label)
        # 加载数据page的标签选择combobox
        self.load_data_select_target_combobox = QtWidgets.QComboBox(self.load_data_page)
        self.load_data_page_but_layout.addWidget(self.load_data_select_target_combobox)
        # 加载数据page的数据划分label
        self.load_data_select_spilt_label = QtWidgets.QLabel(self.load_data_page)
        self.load_data_select_spilt_label.setAlignment(
            QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.load_data_page_but_layout.addWidget(self.load_data_select_spilt_label)
        # 加载数据page的数据划分combobox
        self.load_data_select_spilt_combobox = QtWidgets.QComboBox(self.load_data_page)
        self.load_data_page_but_layout.addWidget(self.load_data_select_spilt_combobox)
        # 加载数据page的确认按钮
        self.sure_data_but = QtWidgets.QPushButton(self.load_data_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.sure_data_but.sizePolicy().hasHeightForWidth())
        self.sure_data_but.setSizePolicy(sizePolicy)
        self.load_data_page_but_layout.addWidget(self.sure_data_but)
        # 将按钮布局添加到加载数据page布局中
        self.load_data_page_layout.addLayout(self.load_data_page_but_layout)
        # 加载数据page的数据table
        self.load_data_table = QtWidgets.QTableView(self.load_data_page)
        self.load_data_table.setContextMenuPolicy(Qt.CustomContextMenu)  # 设置策略为自定义菜单
        self.load_data_table.customContextMenuRequested.connect(self.load_data_table_menu)  # 自定义菜单连接槽函数
        self.load_data_page_layout.addWidget(self.load_data_table)
        #  将加载数据page添加到底部总stack中
        self.total_stack.addWidget(self.load_data_page)
        # 数据预处理page及布局
        self.process_page = QtWidgets.QWidget()
        self.process_page_layout = QtWidgets.QHBoxLayout(self.process_page)
        self.process_page_layout.setContentsMargins(0, 0, 0, 0)
        self.process_page_layout.setSpacing(3)
        # 数据预处理page的选择功能stack
        self.process_select_stack = QtWidgets.QStackedWidget(self.process_page)
        # 数据预处理page的选择功能stack的特征选择page及布局
        self.selcet_feature_page = QtWidgets.QWidget()
        self.selcet_feature_page_layout = QtWidgets.QVBoxLayout(self.selcet_feature_page)
        self.selcet_feature_page_layout.setContentsMargins(9, 20, 9, 30)
        self.selcet_feature_page_layout.setSpacing(30)
        # 特征选择的n_estimators布局
        self.feature_n_layout = QtWidgets.QHBoxLayout()
        self.feature_n_layout.setContentsMargins(-1, -1, 300, -1)
        self.feature_n_layout.setSpacing(10)
        # 特征选择的n_estimators的label
        self.feature_n_label = QtWidgets.QLabel(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_n_label.sizePolicy().hasHeightForWidth())
        self.feature_n_label.setSizePolicy(sizePolicy)
        self.feature_n_label.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.feature_n_label.setScaledContents(False)
        self.feature_n_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.feature_n_layout.addWidget(self.feature_n_label)
        # 特征选择的n_estimators的lineedit
        self.feature_n_lineEdit = QtWidgets.QLineEdit(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_n_lineEdit.sizePolicy().hasHeightForWidth())
        self.feature_n_lineEdit.setSizePolicy(sizePolicy)
        self.feature_n_lineEdit.setClearButtonEnabled(False)
        self.feature_n_lineEdit.setText('1000')
        validator = QRegExpValidator(QRegExp('^[0-9]{6}$'))
        self.feature_n_lineEdit.setValidator(validator)
        self.feature_n_lineEdit.setPlaceholderText("请输入大于0的整数")
        self.feature_n_layout.addWidget(self.feature_n_lineEdit)
        self.selcet_feature_page_layout.addLayout(self.feature_n_layout)
        # 特征选择的max_depth布局
        self.feature_th_max_depth_layout = QtWidgets.QHBoxLayout()
        self.feature_th_max_depth_layout.setContentsMargins(0, -1, 300, -1)
        self.feature_th_max_depth_layout.setSpacing(10)
        # 特征选择的max_depth的label
        self.feature_max_depth_label = QtWidgets.QLabel(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_max_depth_label.sizePolicy().hasHeightForWidth())
        self.feature_max_depth_label.setSizePolicy(sizePolicy)
        self.feature_max_depth_label.setAlignment(
            QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.feature_th_max_depth_layout.addWidget(self.feature_max_depth_label)
        # 特征选择的max_depth的lineedit
        self.feature_max_depth_lineEdit = QtWidgets.QLineEdit(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_max_depth_lineEdit.sizePolicy().hasHeightForWidth())
        self.feature_max_depth_lineEdit.setSizePolicy(sizePolicy)
        self.feature_max_depth_lineEdit.setText('3')
        validator = QRegExpValidator(QRegExp('^[0-9]{2}$'))
        self.feature_max_depth_lineEdit.setValidator(validator)
        self.feature_max_depth_lineEdit.setPlaceholderText("请输入大于0的整数")
        self.feature_th_max_depth_layout.addWidget(self.feature_max_depth_lineEdit)
        self.selcet_feature_page_layout.addLayout(self.feature_th_max_depth_layout)
        # 特征选择的是否标准化checkBox
        self.feature_standard_checkBox = QtWidgets.QCheckBox(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_standard_checkBox.sizePolicy().hasHeightForWidth())
        self.feature_standard_checkBox.setSizePolicy(sizePolicy)
        self.feature_standard_checkBox.setTristate(False)
        self.selcet_feature_page_layout.addWidget(self.feature_standard_checkBox, 0, QtCore.Qt.AlignHCenter)
        # 特征选择的开始特征选择按钮
        self.start_fea_select_but = QtWidgets.QPushButton(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.start_fea_select_but.sizePolicy().hasHeightForWidth())
        self.start_fea_select_but.setSizePolicy(sizePolicy)
        self.start_fea_select_but.setFocusPolicy(QtCore.Qt.StrongFocus)
        self.start_fea_select_but.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.start_fea_select_but.setAutoFillBackground(False)
        self.start_fea_select_but.setStyleSheet("alignment:HCenter;")
        self.start_fea_select_but.setAutoRepeat(False)
        self.start_fea_select_but.setAutoExclusive(False)
        self.start_fea_select_but.setAutoDefault(False)
        self.start_fea_select_but.setDefault(False)
        self.start_fea_select_but.setFlat(False)
        self.selcet_feature_page_layout.addWidget(self.start_fea_select_but, 0, QtCore.Qt.AlignHCenter)
        # 特征选择的阈值布局
        self.feature_th_layout = QtWidgets.QHBoxLayout()
        self.feature_th_layout.setContentsMargins(-1, -1, 300, -1)
        self.feature_th_layout.setSpacing(10)
        # 特征选择的阈值布局的label
        self.feature_th_label = QtWidgets.QLabel(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_th_label.sizePolicy().hasHeightForWidth())
        self.feature_th_label.setSizePolicy(sizePolicy)
        self.feature_th_label.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.feature_th_label.setScaledContents(False)
        self.feature_th_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.feature_th_layout.addWidget(self.feature_th_label)
        # 特征选择的阈值布局的lineedit
        self.feature_th_lineedit = QtWidgets.QLineEdit(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_th_lineedit.sizePolicy().hasHeightForWidth())
        self.feature_th_lineedit.setSizePolicy(sizePolicy)
        self.feature_th_lineedit.setClearButtonEnabled(False)
        validator = QRegExpValidator(QRegExp('^[0-9\.]{5}$'))
        self.feature_th_lineedit.setValidator(validator)
        # self.feature_th_lineedit.setPlaceholderText("请输入")
        self.feature_th_layout.addWidget(self.feature_th_lineedit)
        self.selcet_feature_page_layout.addLayout(self.feature_th_layout)
        # 特征选择的确认阈值按钮
        self.feature_th_sure_but = QtWidgets.QPushButton(self.selcet_feature_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.feature_th_sure_but.sizePolicy().hasHeightForWidth())
        self.feature_th_sure_but.setSizePolicy(sizePolicy)
        self.feature_th_sure_but.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.selcet_feature_page_layout.addWidget(self.feature_th_sure_but, 0, QtCore.Qt.AlignHCenter)
        # 将特征选择page添加到数据预处理page的选择功能stack中
        self.process_select_stack.addWidget(self.selcet_feature_page)
        # 数据预处理page的选择功能stack的均衡化page及布局
        self.equal_page = QtWidgets.QWidget()
        self.equal_page_layout = QtWidgets.QVBoxLayout(self.equal_page)
        self.equal_page_layout.setContentsMargins(9, 20, 9, 50)
        self.equal_page_layout.setSpacing(50)
        # 均衡化的模式选择布局
        self.equal_mode_layout = QtWidgets.QHBoxLayout()
        self.equal_mode_layout.setContentsMargins(10, -1, 300, 0)
        self.equal_mode_layout.setSpacing(10)
        # 均衡化的模式选择的label
        self.equal_mode_label = QtWidgets.QLabel(self.equal_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.equal_mode_label.sizePolicy().hasHeightForWidth())
        self.equal_mode_label.setSizePolicy(sizePolicy)
        self.equal_mode_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.equal_mode_layout.addWidget(self.equal_mode_label)
        # 均衡化的模式选择的combobox
        self.equal_mode_combobox = QtWidgets.QComboBox(self.equal_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.equal_mode_combobox.sizePolicy().hasHeightForWidth())
        self.equal_mode_combobox.setSizePolicy(sizePolicy)
        self.equal_mode_layout.addWidget(self.equal_mode_combobox)
        # 将均衡化模式选择布局添加到均衡化page
        self.equal_page_layout.addLayout(self.equal_mode_layout)
        # 均衡化的方式选择布局
        self.equal_method_layout = QtWidgets.QHBoxLayout()
        self.equal_method_layout.setContentsMargins(10, -1, 300, -1)
        self.equal_method_layout.setSpacing(10)
        # 均衡化的方式选择的label
        self.equal_method_label = QtWidgets.QLabel(self.equal_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.equal_method_label.sizePolicy().hasHeightForWidth())
        self.equal_method_label.setSizePolicy(sizePolicy)
        self.equal_method_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.equal_method_layout.addWidget(self.equal_method_label)
        # 均衡化的方式选择的combobox
        self.equal_method_comboBox = QtWidgets.QComboBox(self.equal_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.equal_method_comboBox.sizePolicy().hasHeightForWidth())
        self.equal_method_comboBox.setSizePolicy(sizePolicy)
        self.equal_method_layout.addWidget(self.equal_method_comboBox)
        # 将均衡化方式选择布局添加到均衡化page
        self.equal_page_layout.addLayout(self.equal_method_layout)
        # 均衡化的选择确认按钮
        self.equal_sure_but = QtWidgets.QPushButton(self.equal_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.equal_sure_but.sizePolicy().hasHeightForWidth())
        self.equal_sure_but.setSizePolicy(sizePolicy)
        self.equal_page_layout.addWidget(self.equal_sure_but, 0, QtCore.Qt.AlignHCenter)
        # 将均衡化page添加到数据预处理page的选择功能stack中
        self.process_select_stack.addWidget(self.equal_page)
        # 数据预处理page的选择功能stack的编码page及布局
        self.code_page = QtWidgets.QWidget()
        self.code_page_layout = QtWidgets.QVBoxLayout(self.code_page)
        self.code_page_layout.setContentsMargins(130, 50, 130, 30)
        self.code_page_layout.setSpacing(5)
        # 编码的编码模式选择布局
        self.code_mode_select_layout = QtWidgets.QHBoxLayout()
        self.code_mode_select_layout.setContentsMargins(30, 0, 200, 0)
        self.code_mode_select_layout.setSpacing(0)
        # 编码的编码模式选择的label
        self.code_mode_selcet_label = QtWidgets.QLabel(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_mode_selcet_label.sizePolicy().hasHeightForWidth())
        self.code_mode_selcet_label.setSizePolicy(sizePolicy)
        self.code_mode_select_layout.addWidget(self.code_mode_selcet_label, 0, QtCore.Qt.AlignHCenter)
        # 编码的编码模式选择的combobox
        self.code_mode_select_comboBox = QtWidgets.QComboBox(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_mode_select_comboBox.sizePolicy().hasHeightForWidth())
        self.code_mode_select_comboBox.setSizePolicy(sizePolicy)
        self.code_mode_select_layout.addWidget(self.code_mode_select_comboBox)
        self.code_page_layout.addLayout(self.code_mode_select_layout)
        # 编码的选择编码数据列布局
        self.code_data_select_layout = QtWidgets.QVBoxLayout()
        self.code_data_select_layout.setContentsMargins(100, 30, 60, 0)
        # 编码的选择编码数据列布局的名称布局
        self.code_data_name_layout = QtWidgets.QHBoxLayout()
        self.code_data_name_layout.setContentsMargins(0, 0, 10, 120)
        self.code_data_name_layout.setSpacing(5)
        # 编码的选择编码数据列布局的名称布局的label
        self.code_data_name_label = QtWidgets.QLabel(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_data_name_label.sizePolicy().hasHeightForWidth())
        self.code_data_name_label.setSizePolicy(sizePolicy)
        self.code_data_name_layout.addWidget(self.code_data_name_label, 0, QtCore.Qt.AlignHCenter)
        # 编码的选择编码数据列布局的名称布局的combobox
        self.code_data_name_comboBox = QtWidgets.QComboBox(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_data_name_comboBox.sizePolicy().hasHeightForWidth())
        self.code_data_name_comboBox.setSizePolicy(sizePolicy)
        self.code_data_name_layout.addWidget(self.code_data_name_comboBox)
        # 编码的选择编码数据列布局的名称布局的添加but
        self.code_data_add_but = QtWidgets.QPushButton(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_data_add_but.sizePolicy().hasHeightForWidth())
        self.code_data_add_but.setSizePolicy(sizePolicy)
        self.code_data_add_but.setMinimumSize(QtCore.QSize(0, 0))
        self.code_data_add_but.setMaximumSize(QtCore.QSize(60, 16777215))
        self.code_data_add_but.setSizeIncrement(QtCore.QSize(0, 0))
        self.code_data_name_layout.addWidget(self.code_data_add_but)
        # 编码的选择编码数据列布局的名称布局的删除but
        self.code_data_del_but = QtWidgets.QPushButton(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_data_del_but.sizePolicy().hasHeightForWidth())
        self.code_data_del_but.setSizePolicy(sizePolicy)
        self.code_data_del_but.setMaximumSize(QtCore.QSize(60, 16777215))
        self.code_data_name_layout.addWidget(self.code_data_del_but)
        # 将名称布局添加到编码的选择编码数据列布局中
        self.code_data_select_layout.addLayout(self.code_data_name_layout)
        # 编码的选择编码数据列布局的list
        self.code_data_list = QtWidgets.QListWidget(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_data_list.sizePolicy().hasHeightForWidth())
        self.code_data_list.setSizePolicy(sizePolicy)
        self.code_data_select_layout.addWidget(self.code_data_list)
        # 编码的选择编码数据列布局的划分
        self.code_data_select_layout.setStretch(0, 1)
        self.code_data_select_layout.setStretch(1, 1)
        # 将选择编码数据列布局添加到编码page中
        self.code_page_layout.addLayout(self.code_data_select_layout)
        # 编码的确认but
        self.code_sure_but = QtWidgets.QPushButton(self.code_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.code_sure_but.sizePolicy().hasHeightForWidth())
        self.code_sure_but.setSizePolicy(sizePolicy)
        self.code_page_layout.addWidget(self.code_sure_but, 0, QtCore.Qt.AlignHCenter)
        # 编码page的划分
        self.code_page_layout.setStretch(0, 1)
        self.code_page_layout.setStretch(1, 2)
        self.code_page_layout.setStretch(2, 1)
        # 将编码page添加到数据预处理page的选择功能stack中
        self.process_select_stack.addWidget(self.code_page)
        # 数据预处理page的选择功能stack的PCA_page及布局
        self.PCA_page = QtWidgets.QWidget()
        self.PCA_page_layout = QtWidgets.QVBoxLayout(self.PCA_page)
        self.PCA_page_layout.setContentsMargins(-1, 15, -1, 15)
        # PCA_page的模式选择布局
        self.PCA_select_layout = QtWidgets.QHBoxLayout()
        self.PCA_select_layout.setContentsMargins(30, 0, 200, 0)
        # PCA_page的模式选择的label
        self.pca_mode_label = QtWidgets.QLabel(self.PCA_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_mode_label.sizePolicy().hasHeightForWidth())
        self.pca_mode_label.setSizePolicy(sizePolicy)
        self.pca_mode_label.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.pca_mode_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.PCA_select_layout.addWidget(self.pca_mode_label, 0, QtCore.Qt.AlignBottom)
        # PCA_page的模式选择的comboBox
        self.pca_mode_comboBox = QtWidgets.QComboBox(self.PCA_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_mode_comboBox.sizePolicy().hasHeightForWidth())
        self.pca_mode_comboBox.setSizePolicy(sizePolicy)
        self.PCA_select_layout.addWidget(self.pca_mode_comboBox, 0, QtCore.Qt.AlignBottom)
        # PCA_page的模式选择布局的划分
        self.PCA_select_layout.setStretch(0, 1)
        self.PCA_select_layout.setStretch(1, 2)
        # 将模式选择布局添加到PCA_page中
        self.PCA_page_layout.addLayout(self.PCA_select_layout)
        # PCA_page的参数选择stack及布局
        self.PCA_parameter_stack = QtWidgets.QStackedWidget(self.PCA_page)
        # PCA_page的参数选择stack的pca参数page及布局
        self.pca_parameter_page = QtWidgets.QWidget()
        self.pca_parameter_page_layout = QtWidgets.QVBoxLayout(self.pca_parameter_page)
        self.pca_parameter_page_layout.setContentsMargins(0, 0, 0, 0)
        # PCA_page的参数选择stack的pca参数page的n参数布局
        self.pca_n_layout = QtWidgets.QHBoxLayout()
        self.pca_n_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的pca参数page的n参数布局的label
        self.pca_n_label = QtWidgets.QLabel(self.pca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_n_label.sizePolicy().hasHeightForWidth())
        self.pca_n_label.setSizePolicy(sizePolicy)
        self.pca_n_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.pca_n_layout.addWidget(self.pca_n_label)
        # PCA_page的参数选择stack的pca参数page的n参数布局的lineEdit
        self.pca_n_lineEdit = QtWidgets.QLineEdit(self.pca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_n_lineEdit.sizePolicy().hasHeightForWidth())
        self.pca_n_lineEdit.setSizePolicy(sizePolicy)
        self.pca_n_layout.addWidget(self.pca_n_lineEdit)
        self.pca_n_lineEdit.setText('0.95')
        validator = QRegExpValidator(QRegExp('^[a-z0-9\.]{4}$'))
        self.pca_n_lineEdit.setValidator(validator)
        # PCA_page的参数选择stack的pca参数page的n参数布局的划分
        self.pca_n_layout.setStretch(0, 1)
        self.pca_n_layout.setStretch(1, 2)
        self.pca_parameter_page_layout.addLayout(self.pca_n_layout)
        # PCA_page的参数选择stack的pca参数page的whiten参数布局
        self.pca_whiten_layout = QtWidgets.QHBoxLayout()
        self.pca_whiten_layout.setContentsMargins(30, -1, 200, -1)
        self.pca_whiten_layout.setSpacing(6)
        # PCA_page的参数选择stack的pca参数page的whiten参数布局的label
        self.pca_whiten_label = QtWidgets.QLabel(self.pca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_whiten_label.sizePolicy().hasHeightForWidth())
        self.pca_whiten_label.setSizePolicy(sizePolicy)
        self.pca_whiten_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.pca_whiten_layout.addWidget(self.pca_whiten_label)
        # PCA_page的参数选择stack的pca参数page的whiten参数布局的comboBox
        self.pca_whiten_comboBox = QtWidgets.QComboBox(self.pca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_whiten_comboBox.sizePolicy().hasHeightForWidth())
        self.pca_whiten_comboBox.setSizePolicy(sizePolicy)
        self.pca_whiten_layout.addWidget(self.pca_whiten_comboBox)
        # PCA_page的参数选择stack的pca参数page的whiten参数布局的划分
        self.pca_whiten_layout.setStretch(0, 1)
        self.pca_whiten_layout.setStretch(1, 2)
        self.pca_parameter_page_layout.addLayout(self.pca_whiten_layout)
        # PCA_page的参数选择stack的pca参数page的svd参数布局
        self.pca_svd_layout = QtWidgets.QHBoxLayout()
        self.pca_svd_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的pca参数page的svd参数布局的label
        self.pca_svd_label = QtWidgets.QLabel(self.pca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_svd_label.sizePolicy().hasHeightForWidth())
        self.pca_svd_label.setSizePolicy(sizePolicy)
        self.pca_svd_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.pca_svd_layout.addWidget(self.pca_svd_label)
        # PCA_page的参数选择stack的pca参数page的svd参数布局的comboBox
        self.pca_svd_comboBox = QtWidgets.QComboBox(self.pca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_svd_comboBox.sizePolicy().hasHeightForWidth())
        self.pca_svd_comboBox.setSizePolicy(sizePolicy)
        self.pca_svd_layout.addWidget(self.pca_svd_comboBox)
        # PCA_page的参数选择stack的pca参数page的svd参数布局的划分
        self.pca_svd_layout.setStretch(0, 1)
        self.pca_svd_layout.setStretch(1, 2)
        self.pca_parameter_page_layout.addLayout(self.pca_svd_layout)
        # 将pca参数page添加到参数选择stack
        self.PCA_parameter_stack.addWidget(self.pca_parameter_page)
        # PCA_page的参数选择stack的kpca参数page及布局
        self.kpca_parameter_page = QtWidgets.QWidget()
        self.kpca_parameter_page_layout = QtWidgets.QVBoxLayout(self.kpca_parameter_page)
        self.kpca_parameter_page_layout.setContentsMargins(0, 0, 0, 0)
        # PCA_page的参数选择stack的kpca参数page的n参数布局
        self.kpca_n_layout = QtWidgets.QHBoxLayout()
        self.kpca_n_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的kpca参数page的n参数布局的label
        self.kpca_n_label = QtWidgets.QLabel(self.kpca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.kpca_n_label.sizePolicy().hasHeightForWidth())
        self.kpca_n_label.setSizePolicy(sizePolicy)
        self.kpca_n_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.kpca_n_layout.addWidget(self.kpca_n_label)
        # PCA_page的参数选择stack的kpca参数page的n参数布局的lineEdit
        self.kpca_n_lineEdit = QtWidgets.QLineEdit(self.kpca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.kpca_n_lineEdit.sizePolicy().hasHeightForWidth())
        self.kpca_n_lineEdit.setSizePolicy(sizePolicy)
        self.kpca_n_layout.addWidget(self.kpca_n_lineEdit)
        self.kpca_n_lineEdit.setText('3')
        validator = QRegExpValidator(QRegExp('^[0-9]{3}$'))
        self.kpca_n_lineEdit.setValidator(validator)
        # PCA_page的参数选择stack的kpca参数page的n参数布局的划分
        self.kpca_n_layout.setStretch(0, 1)
        self.kpca_n_layout.setStretch(1, 2)
        self.kpca_parameter_page_layout.addLayout(self.kpca_n_layout)
        # PCA_page的参数选择stack的kpca参数page的kernel参数布局
        self.kpca_kernel_layout = QtWidgets.QHBoxLayout()
        self.kpca_kernel_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的kpca参数page的kernel参数布局的label
        self.kpca_kernel_label = QtWidgets.QLabel(self.kpca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.kpca_kernel_label.sizePolicy().hasHeightForWidth())
        self.kpca_kernel_label.setSizePolicy(sizePolicy)
        self.kpca_kernel_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.kpca_kernel_layout.addWidget(self.kpca_kernel_label)
        # PCA_page的参数选择stack的kpca参数page的kernel参数布局的comboBox
        self.kpca_kernel_comboBox = QtWidgets.QComboBox(self.kpca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.kpca_kernel_comboBox.sizePolicy().hasHeightForWidth())
        self.kpca_kernel_comboBox.setSizePolicy(sizePolicy)
        self.kpca_kernel_layout.addWidget(self.kpca_kernel_comboBox)
        # PCA_page的参数选择stack的kpca参数page的kernel参数布局的划分
        self.kpca_kernel_layout.setStretch(0, 1)
        self.kpca_kernel_layout.setStretch(1, 2)
        self.kpca_parameter_page_layout.addLayout(self.kpca_kernel_layout)
        # 将kpca参数page添加到参数选择stack
        self.PCA_parameter_stack.addWidget(self.kpca_parameter_page)
        # PCA_page的参数选择stack的ipca参数page及布局
        self.ipca_parameter_page = QtWidgets.QWidget()
        self.ipca_parameter_page_layout = QtWidgets.QVBoxLayout(self.ipca_parameter_page)
        self.ipca_parameter_page_layout.setContentsMargins(0, 0, 0, 0)
        # PCA_page的参数选择stack的ipca参数page的n参数布局
        self.ipca_n_layout = QtWidgets.QHBoxLayout()
        self.ipca_n_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的ipca参数page的n参数布局的label
        self.ipca_n_label = QtWidgets.QLabel(self.ipca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ipca_n_label.sizePolicy().hasHeightForWidth())
        self.ipca_n_label.setSizePolicy(sizePolicy)
        self.ipca_n_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.ipca_n_layout.addWidget(self.ipca_n_label)
        # PCA_page的参数选择stack的ipca参数page的n参数布局的lineEdit
        self.ipca_n_lineEdit = QtWidgets.QLineEdit(self.ipca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ipca_n_lineEdit.sizePolicy().hasHeightForWidth())
        self.ipca_n_lineEdit.setSizePolicy(sizePolicy)
        self.ipca_n_layout.addWidget(self.ipca_n_lineEdit)
        self.ipca_n_lineEdit.setText('3')
        validator = QRegExpValidator(QRegExp('^[0-9]{3}$'))
        self.ipca_n_lineEdit.setValidator(validator)
        # PCA_page的参数选择stack的ipca参数page的n参数布局的划分
        self.ipca_n_layout.setStretch(0, 1)
        self.ipca_n_layout.setStretch(1, 2)
        self.ipca_parameter_page_layout.addLayout(self.ipca_n_layout)
        # PCA_page的参数选择stack的ipca参数page的whiten参数布局
        self.ipca_whiten_layout = QtWidgets.QHBoxLayout()
        self.ipca_whiten_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的ipca参数page的whiten参数布局的label
        self.ipca_whiten_label = QtWidgets.QLabel(self.ipca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ipca_whiten_label.sizePolicy().hasHeightForWidth())
        self.ipca_whiten_label.setSizePolicy(sizePolicy)
        self.ipca_whiten_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.ipca_whiten_layout.addWidget(self.ipca_whiten_label)
        # PCA_page的参数选择stack的ipca参数page的whiten参数布局的comboBox
        self.ipca_whiten_comboBox = QtWidgets.QComboBox(self.ipca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ipca_whiten_comboBox.sizePolicy().hasHeightForWidth())
        self.ipca_whiten_comboBox.setSizePolicy(sizePolicy)
        self.ipca_whiten_layout.addWidget(self.ipca_whiten_comboBox)
        # PCA_page的参数选择stack的ipca参数page的whiten参数布局的划分
        self.ipca_whiten_layout.setStretch(0, 1)
        self.ipca_whiten_layout.setStretch(1, 2)
        self.ipca_parameter_page_layout.addLayout(self.ipca_whiten_layout)
        # PCA_page的参数选择stack的ipca参数page的batch参数布局
        self.ipca_batch_layout = QtWidgets.QHBoxLayout()
        self.ipca_batch_layout.setContentsMargins(30, -1, 200, -1)
        # PCA_page的参数选择stack的ipca参数page的batch参数布局的label
        self.ipca_batch_label = QtWidgets.QLabel(self.ipca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ipca_batch_label.sizePolicy().hasHeightForWidth())
        self.ipca_batch_label.setSizePolicy(sizePolicy)
        self.ipca_batch_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.ipca_batch_layout.addWidget(self.ipca_batch_label)
        # PCA_page的参数选择stack的ipca参数page的batch参数布局的lineEdit
        self.ipca_batch_lineEdit = QtWidgets.QLineEdit(self.ipca_parameter_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.ipca_batch_lineEdit.sizePolicy().hasHeightForWidth())
        self.ipca_batch_lineEdit.setSizePolicy(sizePolicy)
        self.ipca_batch_layout.addWidget(self.ipca_batch_lineEdit)
        self.ipca_batch_lineEdit.setText('10')
        validator = QRegExpValidator(QRegExp('^[0-9]{4}$'))
        self.ipca_n_lineEdit.setValidator(validator)
        # PCA_page的参数选择stack的ipca参数page的batch参数布局的划分
        self.ipca_batch_layout.setStretch(0, 1)
        self.ipca_batch_layout.setStretch(1, 2)
        self.ipca_parameter_page_layout.addLayout(self.ipca_batch_layout)
        # 将ipca参数page添加到参数选择stack
        self.PCA_parameter_stack.addWidget(self.ipca_parameter_page)
        # 将参数选择stack添加到PCA_page布局中
        self.PCA_page_layout.addWidget(self.PCA_parameter_stack)
        # PCA_page的按钮布局
        self.PCA_sure_layout = QtWidgets.QHBoxLayout()
        self.PCA_sure_layout.setContentsMargins(40, -1, 40, -1)
        self.PCA_sure_layout.setSpacing(10)
        # PCA_page的按钮布局的开始按钮
        self.pca_start_but = QtWidgets.QPushButton(self.PCA_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_start_but.sizePolicy().hasHeightForWidth())
        self.pca_start_but.setSizePolicy(sizePolicy)
        self.PCA_sure_layout.addWidget(self.pca_start_but, 0, QtCore.Qt.AlignTop)
        # PCA_page的按钮布局的确认按钮
        self.pca_sure_but = QtWidgets.QPushButton(self.PCA_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pca_sure_but.sizePolicy().hasHeightForWidth())
        self.pca_sure_but.setSizePolicy(sizePolicy)
        self.PCA_sure_layout.addWidget(self.pca_sure_but, 0, QtCore.Qt.AlignTop)
        # 将按钮布局添加到PCA_page布局
        self.PCA_page_layout.addLayout(self.PCA_sure_layout)
        # PCA_page布局的划分
        self.PCA_page_layout.setStretch(0, 1)
        self.PCA_page_layout.setStretch(1, 6)
        self.PCA_page_layout.setStretch(2, 1)
        # 将PCA_page添加到数据预处理page的选择功能stack中
        self.process_select_stack.addWidget(self.PCA_page)
        # 将预处理选择stack加入数据预处理page里
        self.process_page_layout.addWidget(self.process_select_stack)
        # 数据预处理page的数据table
        self.process_table = QtWidgets.QTableView(self.process_page)
        # self.process_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        # self.process_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.process_table.setContextMenuPolicy(Qt.CustomContextMenu)  # 设置策略为自定义菜单
        self.process_table.customContextMenuRequested.connect(self.process_table_menu)  # 自定义菜单连接槽函数
        self.process_page_layout.addWidget(self.process_table)
        self.process_page_layout.setStretch(0, 2)
        self.process_page_layout.setStretch(1, 1)
        self.total_stack.addWidget(self.process_page)
        # 模型page及布局
        self.model_page = QtWidgets.QWidget()
        self.model_page_layout = QtWidgets.QHBoxLayout(self.model_page)
        self.model_page_layout.setContentsMargins(0, 0, 0, 0)
        self.model_page_layout.setSpacing(10)
        # 模型page的模型列表布局
        self.model_list_layout = QtWidgets.QVBoxLayout()
        self.model_list_layout.setSpacing(0)
        # 模型page的模型列表的label
        self.mode_select_label = QtWidgets.QLabel(self.model_page)
        self.mode_select_label.setFrameShape(QtWidgets.QFrame.Box)
        self.mode_select_label.setFrameShadow(QtWidgets.QFrame.Raised)
        self.mode_select_label.setLineWidth(1)
        self.mode_select_label.setAlignment(QtCore.Qt.AlignLeading | QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
        self.model_list_layout.addWidget(self.mode_select_label)
        # 模型page的模型列表的viewlist
        self.model_list = QtWidgets.QListWidget(self.model_page)
        self.model_list.setFrameShape(QtWidgets.QFrame.Box)
        self.model_list.setFrameShadow(QtWidgets.QFrame.Raised)
        self.model_list.setLineWidth(2)
        self.model_list_layout.addWidget(self.model_list)
        # 将模型列表布局添加到模型page布局中
        self.model_page_layout.addLayout(self.model_list_layout)
        # 模型page的右边布局
        self.model_right_layout = QtWidgets.QVBoxLayout()
        self.model_right_layout.setContentsMargins(0, -1, 0, 0)
        self.model_right_layout.setSpacing(6)
        # 模型page的右边布局的选择stack
        self.model_page_select_stack = QtWidgets.QStackedWidget(self.model_page)
        self.model_page_select_stack.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.model_page_select_stack.setLineWidth(1)
        # 模型page的右边布局的选择stack的模型训练page及布局
        self.model_train_page = QtWidgets.QWidget()
        self.model_train_page_layout = QtWidgets.QVBoxLayout(self.model_train_page)
        self.model_train_page_layout.setContentsMargins(0, 0, 0, 0)
        self.model_train_page_layout.setSpacing(3)
        # 模型page的右边布局的选择stack的模型训练page的模型选择stack
        self.model_train_select_stack = QtWidgets.QStackedWidget(self.model_train_page)
        # 逻辑回归page及布局
        self.lr_train = QtWidgets.QWidget()
        self.lr_train_layout = QtWidgets.QVBoxLayout(self.lr_train)
        self.lr_train_layout.setContentsMargins(9, 9, 9, 9)
        self.lr_train_layout.setSpacing(6)
        # 逻辑回归page的预处理布局
        self.lr_process_layout = QtWidgets.QHBoxLayout()
        self.lr_process_layout.setContentsMargins(10, -1, 300, -1)
        self.lr_process_layout.setSpacing(10)
        # 逻辑回归page的预处理的label
        self.lr_process_label = QtWidgets.QLabel(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_process_label.sizePolicy().hasHeightForWidth())
        self.lr_process_label.setSizePolicy(sizePolicy)
        self.lr_process_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.lr_process_layout.addWidget(self.lr_process_label)
        # 逻辑回归page的预处理的combobox
        self.lr_process_comboBox = QtWidgets.QComboBox(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_process_comboBox.sizePolicy().hasHeightForWidth())
        self.lr_process_comboBox.setSizePolicy(sizePolicy)
        self.lr_process_layout.addWidget(self.lr_process_comboBox)
        # 将预处理布局添加到逻辑回归page布局中
        self.lr_train_layout.addLayout(self.lr_process_layout)
        # 逻辑回归page的max_iter布局
        self.lr_max_iter_layout = QtWidgets.QHBoxLayout()
        self.lr_max_iter_layout.setContentsMargins(10, -1, 300, -1)
        self.lr_max_iter_layout.setSpacing(10)
        # 逻辑回归page的max_iter的label
        self.lr_max_iter_label = QtWidgets.QLabel(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_max_iter_label.sizePolicy().hasHeightForWidth())
        self.lr_max_iter_label.setSizePolicy(sizePolicy)
        self.lr_max_iter_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing)
        self.lr_max_iter_layout.addWidget(self.lr_max_iter_label)
        # 逻辑回归page的max_iter的lineEdit
        self.lr_max_iter_lineEdit = QtWidgets.QLineEdit(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_max_iter_lineEdit.sizePolicy().hasHeightForWidth())
        self.lr_max_iter_lineEdit.setSizePolicy(sizePolicy)
        self.lr_max_iter_lineEdit.setText('1000')
        validator = QRegExpValidator(QRegExp('^[0-9]{5}$'))
        self.lr_max_iter_lineEdit.setValidator(validator)
        self.lr_max_iter_lineEdit.setPlaceholderText("请输入大于0的整数")
        self.lr_max_iter_layout.addWidget(self.lr_max_iter_lineEdit)
        # 将max_iter局添加到逻辑回归page布局中
        self.lr_train_layout.addLayout(self.lr_max_iter_layout)
        # 逻辑回归stack的penalty布局
        self.lr_penalty_layout = QtWidgets.QHBoxLayout()
        self.lr_penalty_layout.setContentsMargins(10, -1, 300, -1)
        self.lr_penalty_layout.setSpacing(10)
        # 逻辑回归page的penalty的label
        self.lr_penalty_label = QtWidgets.QLabel(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_penalty_label.sizePolicy().hasHeightForWidth())
        self.lr_penalty_label.setSizePolicy(sizePolicy)
        self.lr_penalty_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing)
        self.lr_penalty_layout.addWidget(self.lr_penalty_label)
        # 逻辑回归page的penalty的comboBox
        self.lr_penalty_comboBox = QtWidgets.QComboBox(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_penalty_comboBox.sizePolicy().hasHeightForWidth())
        self.lr_penalty_comboBox.setSizePolicy(sizePolicy)
        self.lr_penalty_layout.addWidget(self.lr_penalty_comboBox)
        # 将penalty局添加到逻辑回归page布局中
        self.lr_train_layout.addLayout(self.lr_penalty_layout)
        # 逻辑回归page的solver布局
        self.lr_solver_layout = QtWidgets.QHBoxLayout()
        self.lr_solver_layout.setContentsMargins(10, -1, 300, -1)
        self.lr_solver_layout.setSpacing(10)
        # 逻辑回归page的solver的label
        self.lr_solver_label = QtWidgets.QLabel(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_solver_label.sizePolicy().hasHeightForWidth())
        self.lr_solver_label.setSizePolicy(sizePolicy)
        self.lr_solver_label.setAlignment(QtCore.Qt.AlignBottom | QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing)
        self.lr_solver_layout.addWidget(self.lr_solver_label)
        # 逻辑回归page的solver的comboBox
        self.lr_solver_comboBox = QtWidgets.QComboBox(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_solver_comboBox.sizePolicy().hasHeightForWidth())
        self.lr_solver_comboBox.setSizePolicy(sizePolicy)
        self.lr_solver_layout.addWidget(self.lr_solver_comboBox)
        # 将solver局添加到逻辑回归page布局中
        self.lr_train_layout.addLayout(self.lr_solver_layout)
        # 逻辑回归page的网格搜索布局
        self.lr_grid_search_layout = QtWidgets.QHBoxLayout()
        self.lr_grid_search_layout.setContentsMargins(0, -1, 0, -1)
        self.lr_grid_search_layout.setSpacing(6)
        # 逻辑回归page的网格搜索的checkBox
        self.lr_grid_search_checkBox = QtWidgets.QCheckBox(self.lr_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lr_grid_search_checkBox.sizePolicy().hasHeightForWidth())
        self.lr_grid_search_checkBox.setSizePolicy(sizePolicy)
        self.lr_grid_search_layout.addWidget(self.lr_grid_search_checkBox, 0, QtCore.Qt.AlignHCenter)
        self.lr_train_layout.addLayout(self.lr_grid_search_layout)
        # 将逻辑回归page添加到模型训练page的模型选择stack中
        self.model_train_select_stack.addWidget(self.lr_train)
        # knn_page及布局
        self.knn_train = QtWidgets.QWidget()
        self.knn_train_layout = QtWidgets.QVBoxLayout(self.knn_train)
        self.knn_train_layout.setContentsMargins(9, 9, 9, 9)
        # knn_page的数据处理布局
        self.knn_process_layout = QtWidgets.QHBoxLayout()
        self.knn_process_layout.setContentsMargins(10, -1, 300, 0)
        self.knn_process_layout.setSpacing(10)
        # knn_page的数据处理的label
        self.knn_process_label = QtWidgets.QLabel(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_process_label.sizePolicy().hasHeightForWidth())
        self.knn_process_label.setSizePolicy(sizePolicy)
        self.knn_process_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.knn_process_layout.addWidget(self.knn_process_label)
        # knn_page的数据处理的comboBox
        self.knn_process_comboBox = QtWidgets.QComboBox(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_process_comboBox.sizePolicy().hasHeightForWidth())
        self.knn_process_comboBox.setSizePolicy(sizePolicy)
        self.knn_process_layout.addWidget(self.knn_process_comboBox)
        # 将数据处理布局添加到knn_page
        self.knn_train_layout.addLayout(self.knn_process_layout)
        # knn_page的n_neighbors参数布局
        self.knn_n_neighbors_layout = QtWidgets.QHBoxLayout()
        self.knn_n_neighbors_layout.setContentsMargins(10, -1, 300, -1)
        self.knn_n_neighbors_layout.setSpacing(10)
        # knn_page的n_neighbors参数的label
        self.knn_n_neighbors_label = QtWidgets.QLabel(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_n_neighbors_label.sizePolicy().hasHeightForWidth())
        self.knn_n_neighbors_label.setSizePolicy(sizePolicy)
        self.knn_n_neighbors_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.knn_n_neighbors_layout.addWidget(self.knn_n_neighbors_label)
        # knn_page的n_neighbors参数的lineEdit
        self.knn_n_neighbors_lineEdit = QtWidgets.QLineEdit(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_n_neighbors_lineEdit.sizePolicy().hasHeightForWidth())
        self.knn_n_neighbors_lineEdit.setSizePolicy(sizePolicy)
        self.knn_n_neighbors_lineEdit.setText('5')
        self.knn_n_neighbors_lineEdit.setPlaceholderText("请输入大于0的奇数")
        validator = QRegExpValidator(QRegExp('^[0-9]{2}$'))
        self.knn_n_neighbors_lineEdit.setValidator(validator)
        self.knn_n_neighbors_layout.addWidget(self.knn_n_neighbors_lineEdit)
        # 将n_neighbors参数布局添加到knn_page
        self.knn_train_layout.addLayout(self.knn_n_neighbors_layout)
        # knn_page的weights参数布局
        self.knn_weights_layout = QtWidgets.QHBoxLayout()
        self.knn_weights_layout.setContentsMargins(10, -1, 300, -1)
        self.knn_weights_layout.setSpacing(10)
        # knn_page的weights参数的label
        self.knn_weights_label = QtWidgets.QLabel(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_weights_label.sizePolicy().hasHeightForWidth())
        self.knn_weights_label.setSizePolicy(sizePolicy)
        self.knn_weights_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.knn_weights_layout.addWidget(self.knn_weights_label)
        # knn_page的weights参数的comboBox
        self.knn_weights_comboBox = QtWidgets.QComboBox(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_weights_comboBox.sizePolicy().hasHeightForWidth())
        self.knn_weights_comboBox.setSizePolicy(sizePolicy)
        self.knn_weights_layout.addWidget(self.knn_weights_comboBox)
        # 将weights参数布局添加到knn_page
        self.knn_train_layout.addLayout(self.knn_weights_layout)
        # knn_page的p参数布局
        self.knn_p_layout = QtWidgets.QHBoxLayout()
        self.knn_p_layout.setContentsMargins(10, -1, 300, -1)
        self.knn_p_layout.setSpacing(10)
        # knn_page的p参数的label
        self.knn_p_label = QtWidgets.QLabel(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_p_label.sizePolicy().hasHeightForWidth())
        self.knn_p_label.setSizePolicy(sizePolicy)
        self.knn_p_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.knn_p_layout.addWidget(self.knn_p_label)
        # knn_page的p参数的comboBox
        self.knn_p_comboBox = QtWidgets.QComboBox(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_p_comboBox.sizePolicy().hasHeightForWidth())
        self.knn_p_comboBox.setSizePolicy(sizePolicy)
        self.knn_p_layout.addWidget(self.knn_p_comboBox)
        # 将p参数布局添加到knn_page
        self.knn_train_layout.addLayout(self.knn_p_layout)
        # knn_page的网格搜索布局
        self.knn_grid_search_layout = QtWidgets.QHBoxLayout()
        # knn_page的网格搜索的checkBox
        self.knn_grid_search_checkBox = QtWidgets.QCheckBox(self.knn_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.knn_grid_search_checkBox.sizePolicy().hasHeightForWidth())
        self.knn_grid_search_checkBox.setSizePolicy(sizePolicy)
        self.knn_grid_search_checkBox.setObjectName("knn_grid_search_checkBox")
        self.knn_grid_search_layout.addWidget(self.knn_grid_search_checkBox, 0, QtCore.Qt.AlignHCenter)
        # 将网格搜索布局添加到knn_page
        self.knn_train_layout.addLayout(self.knn_grid_search_layout)
        # 将knn_page添加到模型训练page的模型选择stack中
        self.model_train_select_stack.addWidget(self.knn_train)
        # tree_page及布局
        self.tree_train = QtWidgets.QWidget()
        self.tree_train_layout = QtWidgets.QVBoxLayout(self.tree_train)
        # tree_page的数据处理布局
        self.tree_process_layout = QtWidgets.QHBoxLayout()
        self.tree_process_layout.setContentsMargins(10, -1, 300, -1)
        self.tree_process_layout.setSpacing(10)
        # tree_page的数据处理的label
        self.tree_process_label = QtWidgets.QLabel(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_process_label.sizePolicy().hasHeightForWidth())
        self.tree_process_label.setSizePolicy(sizePolicy)
        self.tree_process_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.tree_process_layout.addWidget(self.tree_process_label)
        # tree_page的数据处理的comboBox
        self.tree_process_comboBox = QtWidgets.QComboBox(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_process_comboBox.sizePolicy().hasHeightForWidth())
        self.tree_process_comboBox.setSizePolicy(sizePolicy)
        self.tree_process_layout.addWidget(self.tree_process_comboBox)
        # 将数据处理布局添加到tree_page
        self.tree_train_layout.addLayout(self.tree_process_layout)
        # tree_page的criterion参数布局
        self.tree_criterion_layout = QtWidgets.QHBoxLayout()
        self.tree_criterion_layout.setContentsMargins(10, -1, 300, -1)
        self.tree_criterion_layout.setSpacing(10)
        # tree_page的criterion参数布局的label
        self.tree_criterion_label = QtWidgets.QLabel(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_criterion_label.sizePolicy().hasHeightForWidth())
        self.tree_criterion_label.setSizePolicy(sizePolicy)
        self.tree_criterion_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.tree_criterion_layout.addWidget(self.tree_criterion_label)
        # tree_page的criterion参数布局的comboBox
        self.tree_criterion_comboBox = QtWidgets.QComboBox(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_criterion_comboBox.sizePolicy().hasHeightForWidth())
        self.tree_criterion_comboBox.setSizePolicy(sizePolicy)
        self.tree_criterion_layout.addWidget(self.tree_criterion_comboBox)
        # 将criterion参数布局添加到tree_page中
        self.tree_train_layout.addLayout(self.tree_criterion_layout)
        # tree_page的max_depth参数布局
        self.tree_depth_layout = QtWidgets.QHBoxLayout()
        self.tree_depth_layout.setContentsMargins(10, -1, 300, -1)
        self.tree_depth_layout.setSpacing(10)
        # tree_page的max_depth参数布局的label
        self.tree_depth_label = QtWidgets.QLabel(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_depth_label.sizePolicy().hasHeightForWidth())
        self.tree_depth_label.setSizePolicy(sizePolicy)
        self.tree_depth_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.tree_depth_layout.addWidget(self.tree_depth_label)
        # tree_page的max_depth参数布局的lineEdit
        self.tree_depth_lineEdit = QtWidgets.QLineEdit(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_depth_lineEdit.sizePolicy().hasHeightForWidth())
        self.tree_depth_lineEdit.setSizePolicy(sizePolicy)
        self.tree_depth_lineEdit.setText('3')
        validator = QRegExpValidator(QRegExp('^[0-9]{2}$'))
        self.tree_depth_lineEdit.setValidator(validator)
        self.tree_depth_lineEdit.setPlaceholderText("请输入大于0的整数")
        self.tree_depth_layout.addWidget(self.tree_depth_lineEdit)
        # 将max_depth参数布局添加到tree_page中
        self.tree_train_layout.addLayout(self.tree_depth_layout)
        # tree_page的splitter参数布局
        self.tree_splitter_layout = QtWidgets.QHBoxLayout()
        self.tree_splitter_layout.setContentsMargins(10, -1, 300, -1)
        self.tree_splitter_layout.setSpacing(10)
        # tree_page的splitter参数布局的label
        self.tree_splitter_label = QtWidgets.QLabel(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_splitter_label.sizePolicy().hasHeightForWidth())
        self.tree_splitter_label.setSizePolicy(sizePolicy)
        self.tree_splitter_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.tree_splitter_layout.addWidget(self.tree_splitter_label)
        # tree_page的splitter参数布局的comboBox
        self.tree_splitter_comboBox = QtWidgets.QComboBox(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_splitter_comboBox.sizePolicy().hasHeightForWidth())
        self.tree_splitter_comboBox.setSizePolicy(sizePolicy)
        self.tree_splitter_layout.addWidget(self.tree_splitter_comboBox)
        # 将splitter参数布局添加到tree_page中
        self.tree_train_layout.addLayout(self.tree_splitter_layout)
        # tree_page的网格搜索checkBox
        self.tree_grid_search_checkBox = QtWidgets.QCheckBox(self.tree_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tree_grid_search_checkBox.sizePolicy().hasHeightForWidth())
        self.tree_grid_search_checkBox.setSizePolicy(sizePolicy)
        self.tree_train_layout.addWidget(self.tree_grid_search_checkBox, 0, QtCore.Qt.AlignHCenter)
        # tree_page布局的控件划分
        self.tree_train_layout.setStretch(0, 2)
        self.tree_train_layout.setStretch(1, 2)
        self.tree_train_layout.setStretch(2, 2)
        self.tree_train_layout.setStretch(3, 2)
        self.tree_train_layout.setStretch(4, 1)
        # 将tree_page添加到模型训练page的模型选择stack中
        self.model_train_select_stack.addWidget(self.tree_train)
        # guass_page及布局
        self.guass_train = QtWidgets.QWidget()
        self.guass_train_layout = QtWidgets.QVBoxLayout(self.guass_train)
        # guass_page的数据处理布局
        self.guass_process_layout = QtWidgets.QHBoxLayout()
        self.guass_process_layout.setContentsMargins(10, -1, 300, -1)
        self.guass_process_layout.setSpacing(10)
        # guass_page的数据处理布局的label
        self.guass_process_label = QtWidgets.QLabel(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_process_label.sizePolicy().hasHeightForWidth())
        self.guass_process_label.setSizePolicy(sizePolicy)
        self.guass_process_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.guass_process_layout.addWidget(self.guass_process_label)
        # guass_page的数据处理布局的comboBox
        self.guass_process_comboBox = QtWidgets.QComboBox(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_process_comboBox.sizePolicy().hasHeightForWidth())
        self.guass_process_comboBox.setSizePolicy(sizePolicy)
        self.guass_process_layout.addWidget(self.guass_process_comboBox)
        # 将数据处理布局添加到guass_page中
        self.guass_train_layout.addLayout(self.guass_process_layout)
        # guass_page的模式选择布局
        self.guass_mode_layout = QtWidgets.QHBoxLayout()
        self.guass_mode_layout.setContentsMargins(10, -1, 300, -1)
        self.guass_mode_layout.setSpacing(10)
        # guass_page的模式选择布局的label
        self.guass_mode_label = QtWidgets.QLabel(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_mode_label.sizePolicy().hasHeightForWidth())
        self.guass_mode_label.setSizePolicy(sizePolicy)
        self.guass_mode_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.guass_mode_layout.addWidget(self.guass_mode_label)
        # guass_page的模式选择布局的comboBox
        self.guass_mode_comboBox = QtWidgets.QComboBox(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_mode_comboBox.sizePolicy().hasHeightForWidth())
        self.guass_mode_comboBox.setSizePolicy(sizePolicy)
        self.guass_mode_layout.addWidget(self.guass_mode_comboBox)
        # 将模式选择布局添加到guass_page中
        self.guass_train_layout.addLayout(self.guass_mode_layout)
        # guass_page的多功能参数布局
        self.guass_multipara_layout = QtWidgets.QHBoxLayout()
        self.guass_multipara_layout.setContentsMargins(10, 0, 300, -1)
        self.guass_multipara_layout.setSpacing(10)
        # guass_page的多功能参数布局的label
        self.guass_multipara_label = QtWidgets.QLabel(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_multipara_label.sizePolicy().hasHeightForWidth())
        self.guass_multipara_label.setSizePolicy(sizePolicy)
        self.guass_multipara_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.guass_multipara_layout.addWidget(self.guass_multipara_label)
        # guass_page的多功能参数布局的lineEdit
        self.guass_multipara_lineEdit = QtWidgets.QLineEdit(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_multipara_lineEdit.sizePolicy().hasHeightForWidth())
        self.guass_multipara_lineEdit.setSizePolicy(sizePolicy)
        self.guass_multipara_lineEdit.setHidden(True)
        validator = QRegExpValidator(QRegExp('^[0-9\.]{3}$'))
        self.guass_multipara_lineEdit.setValidator(validator)
        self.guass_multipara_layout.addWidget(self.guass_multipara_lineEdit)
        # 将多功能参数布局添加到guass_page布局中
        self.guass_train_layout.addLayout(self.guass_multipara_layout)
        # guass_page的网格搜索checkBox
        self.guass_grid_search_checkBox = QtWidgets.QCheckBox(self.guass_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.guass_grid_search_checkBox.sizePolicy().hasHeightForWidth())
        self.guass_grid_search_checkBox.setSizePolicy(sizePolicy)
        self.guass_train_layout.addWidget(self.guass_grid_search_checkBox, 0, QtCore.Qt.AlignHCenter)
        # guass_page布局的控件划分
        self.guass_train_layout.setStretch(0, 1)
        self.guass_train_layout.setStretch(1, 1)
        self.guass_train_layout.setStretch(2, 1)
        self.guass_train_layout.setStretch(3, 1)
        # 将guass_page添加到模型训练page的模型选择stack中
        self.model_train_select_stack.addWidget(self.guass_train)
        # svm_page及布局
        self.svm_train = QtWidgets.QWidget()
        self.svm_train_layout = QtWidgets.QVBoxLayout(self.svm_train)
        # svm_page的数据处理布局
        self.svm_process_layout = QtWidgets.QHBoxLayout()
        self.svm_process_layout.setContentsMargins(10, -1, 300, -1)
        self.svm_process_layout.setSpacing(10)
        # svm_page的数据处理布局的label
        self.svm_process_label = QtWidgets.QLabel(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_process_label.sizePolicy().hasHeightForWidth())
        self.svm_process_label.setSizePolicy(sizePolicy)
        self.svm_process_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.svm_process_layout.addWidget(self.svm_process_label)
        # svm_page的数据处理布局的comboBox
        self.svm_process_comboBox = QtWidgets.QComboBox(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_process_comboBox.sizePolicy().hasHeightForWidth())
        self.svm_process_comboBox.setSizePolicy(sizePolicy)
        self.svm_process_layout.addWidget(self.svm_process_comboBox)
        # 将数据处理布局添加到svm_page布局中
        self.svm_train_layout.addLayout(self.svm_process_layout)
        # svm_page的c参数布局
        self.svm_c_layout = QtWidgets.QHBoxLayout()
        self.svm_c_layout.setContentsMargins(10, -1, 300, -1)
        self.svm_c_layout.setSpacing(10)
        # svm_page的c参数布局的label
        self.svm_c_label = QtWidgets.QLabel(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_c_label.sizePolicy().hasHeightForWidth())
        self.svm_c_label.setSizePolicy(sizePolicy)
        self.svm_c_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.svm_c_layout.addWidget(self.svm_c_label)
        # svm_page的c参数布局的lineEdit
        self.svm_c_lineEdit = QtWidgets.QLineEdit(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_c_lineEdit.sizePolicy().hasHeightForWidth())
        self.svm_c_lineEdit.setSizePolicy(sizePolicy)
        self.svm_c_lineEdit.setText('1.0')
        validator = QRegExpValidator(QRegExp('^[0-9\.]{5}$'))
        self.svm_c_lineEdit.setValidator(validator)
        self.svm_c_lineEdit.setPlaceholderText("请输入大于0的浮点数")
        self.svm_c_layout.addWidget(self.svm_c_lineEdit)
        # 将c参数布局添加到svm_page布局中
        self.svm_train_layout.addLayout(self.svm_c_layout)
        # svm_page的kernel参数布局
        self.svm_kernel_layout = QtWidgets.QHBoxLayout()
        self.svm_kernel_layout.setContentsMargins(10, -1, 300, -1)
        self.svm_kernel_layout.setSpacing(10)
        # svm_page的kernel参数布局的label
        self.svm_kernel_label = QtWidgets.QLabel(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_kernel_label.sizePolicy().hasHeightForWidth())
        self.svm_kernel_label.setSizePolicy(sizePolicy)
        self.svm_kernel_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.svm_kernel_layout.addWidget(self.svm_kernel_label)
        # svm_page的kernel参数布局的comboBox
        self.svm_kernel_comboBox = QtWidgets.QComboBox(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_kernel_comboBox.sizePolicy().hasHeightForWidth())
        self.svm_kernel_comboBox.setSizePolicy(sizePolicy)
        self.svm_kernel_layout.addWidget(self.svm_kernel_comboBox)
        # 将kernel参数布局添加到svm_page中
        self.svm_train_layout.addLayout(self.svm_kernel_layout)
        # svm_page的网格搜索checkBox
        self.svm_grid_search_checkBox = QtWidgets.QCheckBox(self.svm_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.svm_grid_search_checkBox.sizePolicy().hasHeightForWidth())
        self.svm_grid_search_checkBox.setSizePolicy(sizePolicy)
        self.svm_train_layout.addWidget(self.svm_grid_search_checkBox, 0, QtCore.Qt.AlignHCenter)
        # svm_page布局的控件划分
        self.svm_train_layout.setStretch(0, 2)
        self.svm_train_layout.setStretch(1, 2)
        self.svm_train_layout.setStretch(2, 2)
        self.svm_train_layout.setStretch(3, 1)
        # 将svm_page添加到模型训练page的模型选择stack中
        self.model_train_select_stack.addWidget(self.svm_train)
        # forest_page及布局
        self.forest_train = QtWidgets.QWidget()
        self.forest_train_layout = QtWidgets.QVBoxLayout(self.forest_train)
        # forest_page的数据处理布局
        self.forest_process_layout = QtWidgets.QHBoxLayout()
        self.forest_process_layout.setContentsMargins(10, -1, 300, -1)
        self.forest_process_layout.setSpacing(10)
        # forest_page的数据处理布局的label
        self.forest_process_label = QtWidgets.QLabel(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_process_label.sizePolicy().hasHeightForWidth())
        self.forest_process_label.setSizePolicy(sizePolicy)
        self.forest_process_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.forest_process_layout.addWidget(self.forest_process_label)
        # forest_page的数据处理布局的comboBox
        self.forest_process_comboBox = QtWidgets.QComboBox(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_process_comboBox.sizePolicy().hasHeightForWidth())
        self.forest_process_comboBox.setSizePolicy(sizePolicy)
        self.forest_process_layout.addWidget(self.forest_process_comboBox)
        # 将数据处理布局添加到forest_page布局中
        self.forest_train_layout.addLayout(self.forest_process_layout)
        # forest_page的n参数布局
        self.forest_n_layout = QtWidgets.QHBoxLayout()
        self.forest_n_layout.setContentsMargins(10, -1, 300, -1)
        self.forest_n_layout.setSpacing(10)
        # forest_page的n参数布局的label
        self.forest_n_label = QtWidgets.QLabel(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_n_label.sizePolicy().hasHeightForWidth())
        self.forest_n_label.setSizePolicy(sizePolicy)
        self.forest_n_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.forest_n_layout.addWidget(self.forest_n_label)
        # forest_page的n参数布局的lineEdit
        self.forest_n_lineEdit = QtWidgets.QLineEdit(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_n_lineEdit.sizePolicy().hasHeightForWidth())
        self.forest_n_lineEdit.setSizePolicy(sizePolicy)
        self.forest_n_lineEdit.setText('1000')
        validator = QRegExpValidator(QRegExp('^[0-9]{5}$'))
        self.forest_n_lineEdit.setValidator(validator)
        self.forest_n_lineEdit.setPlaceholderText("请输入大于0的整数")
        self.forest_n_layout.addWidget(self.forest_n_lineEdit)
        # 将n参数布局添加到forest_page布局中
        self.forest_train_layout.addLayout(self.forest_n_layout)
        # forest_page的depth参数布局
        self.forest_depth_layout = QtWidgets.QHBoxLayout()
        self.forest_depth_layout.setContentsMargins(10, -1, 300, -1)
        self.forest_depth_layout.setSpacing(10)
        # forest_page的depth参数布局的label
        self.forest_depth_label = QtWidgets.QLabel(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_depth_label.sizePolicy().hasHeightForWidth())
        self.forest_depth_label.setSizePolicy(sizePolicy)
        self.forest_depth_label.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
        self.forest_depth_layout.addWidget(self.forest_depth_label)
        # forest_page的depth参数布局的lineEdit
        self.forest_depth_lineEdit = QtWidgets.QLineEdit(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_depth_lineEdit.sizePolicy().hasHeightForWidth())
        self.forest_depth_lineEdit.setSizePolicy(sizePolicy)
        self.forest_depth_lineEdit.setText('3')
        validator = QRegExpValidator(QRegExp('^[0-9]{2}$'))
        self.forest_depth_lineEdit.setValidator(validator)
        self.forest_depth_lineEdit.setPlaceholderText("请输入大于0的整数")
        self.forest_depth_layout.addWidget(self.forest_depth_lineEdit)
        # 将depth参数布局添加到forest_page布局中
        self.forest_train_layout.addLayout(self.forest_depth_layout)
        # forest_page的网格搜索checkBox
        self.forest_grid_search_checkBox = QtWidgets.QCheckBox(self.forest_train)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.forest_grid_search_checkBox.sizePolicy().hasHeightForWidth())
        self.forest_grid_search_checkBox.setSizePolicy(sizePolicy)
        self.forest_train_layout.addWidget(self.forest_grid_search_checkBox, 0, QtCore.Qt.AlignHCenter)
        # forest_page布局的参数划分
        self.forest_train_layout.setStretch(0, 2)
        self.forest_train_layout.setStretch(1, 2)
        self.forest_train_layout.setStretch(2, 2)
        self.forest_train_layout.setStretch(3, 1)
        # 将forest_page添加到模型训练page的模型选择stack中
        self.model_train_select_stack.addWidget(self.forest_train)
        # 模型训练page的模型选择stack的空stack
        self.model_train_empty_page = QtWidgets.QWidget()
        self.model_train_select_stack.addWidget(self.model_train_empty_page)
        # 将模型选择stack添加到模型训练page布局中
        self.model_train_page_layout.addWidget(self.model_train_select_stack)
        # 将模型训练page添加到右边布局的选择stack中
        self.model_page_select_stack.addWidget(self.model_train_page)
        # 右边布局的选择stack的模型评估page及布局
        self.model_assess_page = QtWidgets.QWidget()
        self.model_assess_page_layout = QtWidgets.QVBoxLayout(self.model_assess_page)
        self.model_assess_page_layout.setContentsMargins(0, 0, 0, 0)
        self.model_assess_page_layout.setSpacing(3)
        # 模型page的选择stack的模型评估page的评估选择stack
        self.model_assess_select_stack = QtWidgets.QStackedWidget(self.model_assess_page)
        # acc_page及布局
        self.model_assess_acc_page = QtWidgets.QWidget()
        self.model_assess_acc_page_layout = QtWidgets.QVBoxLayout(self.model_assess_acc_page)
        # acc_page的table
        self.acc_table = QtWidgets.QTableView(self.model_assess_acc_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        self.acc_table.setSizePolicy(sizePolicy)
        self.model_assess_acc_page_layout.addWidget(self.acc_table)
        # 将acc_page添加到模型评估page的评估选择stack中
        self.model_assess_select_stack.addWidget(self.model_assess_acc_page)
        # martix_page及布局
        self.model_assess_martix_page = QtWidgets.QWidget()
        self.model_assess_martix_page_layout = QtWidgets.QVBoxLayout(self.model_assess_martix_page)
        self.model_assess_martix_page_layout.setContentsMargins(20, 20, 20, 20)
        self.model_assess_martix_page_layout.setSpacing(6)
        # martix_page的table
        self.martix_table = QtWidgets.QTableView(self.model_assess_martix_page)
        self.martix_table.setContextMenuPolicy(Qt.CustomContextMenu)  # 设置策略为自定义菜单
        self.martix_table.customContextMenuRequested.connect(self.martix_table_menu)  # 自定义菜单连接槽函数
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        self.martix_table.setSizePolicy(sizePolicy)
        self.model_assess_martix_page_layout.addWidget(self.martix_table)
        # 将martix_page添加到模型评估page的评估选择stack中
        self.model_assess_select_stack.addWidget(self.model_assess_martix_page)
        # 模型评估图page及布局
        self.model_assess_graphic_page = QtWidgets.QWidget()
        self.model_assess_graphic_page_layout = QtWidgets.QVBoxLayout(self.model_assess_graphic_page)
        self.model_assess_graphic_page_layout.setContentsMargins(9, 9, 9, 9)
        # 模型评估图page的graphic_view
        self.graphic_view = QtWidgets.QGraphicsView(self.model_assess_graphic_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.graphic_view.sizePolicy().hasHeightForWidth())
        self.graphic_view.setSizePolicy(sizePolicy)
        self.model_assess_graphic_page_layout.addWidget(self.graphic_view)
        # 模型评估图page的but
        self.graphic_edit_but = QtWidgets.QPushButton(self.model_assess_graphic_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.graphic_edit_but.sizePolicy().hasHeightForWidth())
        self.graphic_edit_but.setSizePolicy(sizePolicy)
        self.model_assess_graphic_page_layout.addWidget(self.graphic_edit_but)
        # 将模型评估图page添加到模型评估page的评估选择stack中
        self.model_assess_select_stack.addWidget(self.model_assess_graphic_page)
        # 预测page及布局
        self.model_assess_model_predict_page = QtWidgets.QWidget()
        self.model_assess_model_predict_page_layout = QtWidgets.QVBoxLayout(self.model_assess_model_predict_page)
        # 预测page的table
        self.model_predict_table = QtWidgets.QTableView(self.model_assess_model_predict_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_predict_table.sizePolicy().hasHeightForWidth())
        self.model_predict_table.setSizePolicy(sizePolicy)
        self.model_assess_model_predict_page_layout.addWidget(self.model_predict_table)
        # 将预测page添加到模型评估page的评估选择stack中
        self.model_assess_select_stack.addWidget(self.model_assess_model_predict_page)
        # 将评估选择stack添加到模型评估page布局中
        self.model_assess_page_layout.addWidget(self.model_assess_select_stack)
        # 将模型评估page添加到右边布局的选择stack中
        self.model_page_select_stack.addWidget(self.model_assess_page)
        # 将选择stack添加到右边布局中
        self.model_right_layout.addWidget(self.model_page_select_stack)
        # 模型按钮stack及布局
        self.model_page_but_stack = QtWidgets.QStackedWidget(self.model_page)
        # 模型按钮stack的保存page及布局
        self.model_save_page = QtWidgets.QWidget()
        self.model_save_page_layout = QtWidgets.QHBoxLayout(self.model_save_page)
        self.model_save_page_layout.setContentsMargins(40, 0, 40, 0)
        # 模型按钮stack的保存page保存but
        self.model_save_but = QtWidgets.QPushButton(self.model_save_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_save_but.sizePolicy().hasHeightForWidth())
        self.model_save_but.setSizePolicy(sizePolicy)
        self.model_save_page_layout.addWidget(self.model_save_but)
        # 模型按钮stack的保存page的查看训练结果but
        self.model_trained_but = QtWidgets.QPushButton(self.model_save_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_trained_but.sizePolicy().hasHeightForWidth())
        self.model_trained_but.setSizePolicy(sizePolicy)
        self.model_save_page_layout.addWidget(self.model_trained_but)
        # 将保存page添加到模型按钮stack
        self.model_page_but_stack.addWidget(self.model_save_page)
        # 模型按钮stack的换页page及布局
        self.model_page_change_page = QtWidgets.QWidget()
        self.model_page_change_page_layout = QtWidgets.QHBoxLayout(self.model_page_change_page)
        self.model_page_change_page_layout.setContentsMargins(20, 0, 20, 0)
        # 模型按钮stack的换页page的上一页but
        self.model_prepage_but = QtWidgets.QPushButton(self.model_page_change_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_prepage_but.sizePolicy().hasHeightForWidth())
        self.model_prepage_but.setSizePolicy(sizePolicy)
        self.model_page_change_page_layout.addWidget(self.model_prepage_but)
        # 模型按钮stack的换页page的label
        self.model_page_label = QtWidgets.QLabel(self.model_page_change_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_page_label.sizePolicy().hasHeightForWidth())
        self.model_page_label.setSizePolicy(sizePolicy)
        self.model_page_label.setAlignment(QtCore.Qt.AlignCenter)
        self.model_page_change_page_layout.addWidget(self.model_page_label)
        # 模型按钮stack的换页page的下一页but
        self.model_nextpage_but = QtWidgets.QPushButton(self.model_page_change_page)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.model_nextpage_but.sizePolicy().hasHeightForWidth())
        self.model_nextpage_but.setSizePolicy(sizePolicy)
        self.model_page_change_page_layout.addWidget(self.model_nextpage_but)
        # 模型按钮stack的换页page的划分
        self.model_page_change_page_layout.setStretch(0, 1)
        self.model_page_change_page_layout.setStretch(1, 2)
        self.model_page_change_page_layout.setStretch(2, 1)
        # 将换页page添加到模型按钮stack
        self.model_page_but_stack.addWidget(self.model_page_change_page)
        # 模型按钮stack的空page及布局
        self.model_empty_page = QtWidgets.QWidget()
        self.model_empty_page_layout = QtWidgets.QHBoxLayout(self.model_empty_page)
        self.model_page_but_stack.addWidget(self.model_empty_page)
        # 将模型按钮page添加到模型右边布局中
        self.model_right_layout.addWidget(self.model_page_but_stack)
        # 模型右stack的划分
        self.model_right_layout.setStretch(0, 6)
        self.model_right_layout.setStretch(1, 1)
        # 将模型右stack添加模型page
        self.model_page_layout.addLayout(self.model_right_layout)
        # 模型page设置控件占比
        self.model_page_layout.setStretch(0, 1)
        self.model_page_layout.setStretch(1, 2)
        # 将模型page添加到底部总stack
        self.total_stack.addWidget(self.model_page)
        # 将底部总stack添加到widget_layout
        self.widget_layout.addWidget(self.total_stack)
        # widget_layout设置占比
        self.widget_layout.setStretch(0, 1)
        self.widget_layout.setStretch(2, 5)
        # 初始化相关控件
        self.retranslateUi(widget)
        self.combobox_additem()
        self.total_stack.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(widget)

    def retranslateUi(self, widget):
        """
        文本初始化
        :param widget:
        :return:
        """
        _translate = QtCore.QCoreApplication.translate
        self.load_data_but.setText(_translate("widget", "导入数据"))
        self.load_menu_label.setText(_translate("widget", "文件"))
        self.select_feature_but.setText(_translate("widget", "特征选择"))
        self.PCA_but.setText(_translate("widget", "PCA"))
        self.equal_but.setText(_translate("widget", "均衡化"))
        self.encode_but.setText(_translate("widget", "编码"))
        self.process_menu_label.setText(_translate("widget", "选项"))
        self.model_start_now_but.setText(_translate("widget", "训练当前"))
        self.model_start_all_but.setText(_translate("widget", "训练所有"))
        self.delete_model_but.setText(_translate("widget", " 删  除 "))
        self.model_train_menu_label.setText(_translate("widget", "模型"))
        self.model_predict_but.setText(_translate("widget", "预测"))
        self.model_assess_but.setText(_translate("widget", "模型评估"))
        self.model_export_but.setText(_translate("widget", "导出"))
        self.model_assess_menu_label.setText(_translate("widget", "评估"))
        self.load_data_select_model_label.setText(_translate("widget", "模型大类:"))
        self.load_data_select_target_label.setText(_translate("widget", "选择标签:"))
        self.load_data_select_spilt_label.setText(_translate("widget", "数据划分:"))
        self.sure_data_but.setText(_translate("widget", "确认导入"))
        self.feature_n_label.setText(_translate("widget", "n_estimators:"))
        self.feature_max_depth_label.setText(_translate("widget", "max_depth:"))
        self.feature_standard_checkBox.setText(_translate("widget", "是否标准化数据"))
        self.start_fea_select_but.setText(_translate("widget", "开始计算特征重要性"))
        self.feature_th_label.setText(_translate("widget", "特征选择阈值:"))
        self.feature_th_sure_but.setText(_translate("widget", "开始进行特征选择"))
        self.equal_mode_label.setText(_translate("widget", "均衡化模式:"))
        self.equal_method_label.setText(_translate("widget", "均衡化方法:"))
        self.equal_sure_but.setText(_translate("widget", "开始预处理"))
        self.code_mode_selcet_label.setText(_translate("widget", "     编码方式："))
        self.code_data_name_label.setText(_translate("widget", "选择需要编码的数据："))
        self.code_data_add_but.setText(_translate("widget", "添加"))
        self.code_data_del_but.setText(_translate("widget", "删除"))
        self.code_sure_but.setText(_translate("widget", "确认开始编码"))
        self.pca_mode_label.setText(_translate("widget", "选择主成分分析方式："))
        self.pca_n_label.setText(_translate("widget", "n_components:"))
        self.pca_whiten_label.setText(_translate("widget", "whiten:"))
        self.pca_svd_label.setText(_translate("widget", "svd_solver:"))
        self.kpca_n_label.setText(_translate("widget", "n_components:"))
        self.kpca_kernel_label.setText(_translate("widget", "kernel:"))
        self.ipca_n_label.setText(_translate("widget", "n_components:"))
        self.ipca_whiten_label.setText(_translate("widget", "whiten："))
        self.ipca_batch_label.setText(_translate("widget", "batch_size:"))
        self.pca_start_but.setText(_translate("widget", "开始主成分分析"))
        self.pca_sure_but.setText(_translate("widget", "确认使用该结果"))
        self.mode_select_label.setText(_translate("widget", " 模型："))
        self.lr_process_label.setText(_translate("widget", "数据预处理:"))
        self.lr_max_iter_label.setText(_translate("widget", "max_iter:"))
        self.lr_penalty_label.setText(_translate("widget", "lr_penalty:"))
        self.lr_solver_label.setText(_translate("widget", "solver:"))
        self.lr_grid_search_checkBox.setText(_translate("widget", "grid_search"))
        self.knn_process_label.setText(_translate("widget", "数据预处理:"))
        self.knn_n_neighbors_label.setText(_translate("widget", "n_neighbors:"))
        self.knn_weights_label.setText(_translate("widget", "weights:"))
        self.knn_p_label.setText(_translate("widget", "p:"))
        self.knn_grid_search_checkBox.setText(_translate("widget", "grid_search"))
        self.tree_process_label.setText(_translate("widget", "数据预处理:"))
        self.tree_criterion_label.setText(_translate("widget", "criterion:"))
        self.tree_depth_label.setText(_translate("widget", "max_depth:"))
        self.tree_splitter_label.setText(_translate("widget", "splitter:"))
        self.tree_grid_search_checkBox.setText(_translate("widget", "grid_search"))
        self.guass_process_label.setText(_translate("widget", "数据预处理:"))
        self.guass_mode_label.setText(_translate("widget", "朴素贝叶斯模式选择:"))
        self.guass_grid_search_checkBox.setText(_translate("widget", "grid_search"))
        self.svm_process_label.setText(_translate("widget", "数据预处理:"))
        self.svm_c_label.setText(_translate("widget", "C:"))
        self.svm_kernel_label.setText(_translate("widget", "kernel:"))
        self.svm_grid_search_checkBox.setText(_translate("widget", "grid_search"))
        self.forest_process_label.setText(_translate("widget", "数据预处理:"))
        self.forest_n_label.setText(_translate("widget", "n_estimators:"))
        self.forest_depth_label.setText(_translate("widget", "max_depth:"))
        self.forest_grid_search_checkBox.setText(_translate("widget", "grid_search"))
        self.graphic_edit_but.setText(_translate("widget", "编辑图像"))
        self.model_save_but.setText(_translate("widget", "保存模型参数"))
        self.model_trained_but.setText(_translate("widget", "模型训练结果"))
        self.model_prepage_but.setText(_translate("widget", "上一页"))
        self.model_page_label.setText(_translate("widget", "共2页/第1页"))
        self.model_nextpage_but.setText(_translate("widget", "下一页"))

    def control_connect(self):
        """
        槽函数连接
        :return:
        """
        # 加载数据界面槽函数
        self.load_data_but.clicked.connect(self.load_data_but_clicked_handle)
        self.load_data_select_spilt_combobox.currentIndexChanged.connect(self.load_data_select_spilt_combobox_handle)
        self.sure_data_but.clicked.connect(self.sure_data_but_handle)
        # 特征选择界面槽函数
        self.select_feature_but.clicked.connect(self.select_feature_but_handle)
        self.start_fea_select_but.clicked.connect(self.start_fea_select_but_handle)
        self.feature_th_sure_but.clicked.connect(self.feature_th_sure_but_handle)
        # 编码界面槽函数
        self.encode_but.clicked.connect(self.encode_but_handle)
        self.code_data_add_but.clicked.connect(self.code_data_add_but_handle)
        self.code_data_del_but.clicked.connect(self.code_data_del_but_handle)
        self.code_sure_but.clicked.connect(self.code_sure_but_handle)
        # PCA界面槽函数
        self.PCA_but.clicked.connect(self.PCA_but_handle)
        self.pca_mode_comboBox.currentIndexChanged.connect(
            lambda: self.PCA_parameter_stack.setCurrentIndex(self.pca_mode_comboBox.currentIndex()))
        self.pca_whiten_comboBox.currentIndexChanged.connect(self.pca_whiten_handle)
        self.pca_svd_comboBox.currentIndexChanged.connect(self.pca_svd_handle)
        self.pca_start_but.clicked.connect(self.pca_start_but_handle)
        self.pca_sure_but.clicked.connect(self.pca_sure_but_handle)
        self.kpca_kernel_comboBox.currentIndexChanged.connect(self.kpca_kernel_handle)
        self.ipca_whiten_comboBox.currentIndexChanged.connect(self.ipca_whiten_handle)
        # 均衡化界面槽函数
        self.equal_but.clicked.connect(self.equal_but_handle)
        self.equal_mode_combobox.currentIndexChanged.connect(self.equal_mode_combobox_handle)
        self.equal_sure_but.clicked.connect(self.equal_sure_but_handle)
        # 模型选择槽函数
        self.model_select_combobox.activated.connect(self.model_select_combobox_handle)
        self.model_list.itemClicked.connect(self.model_list_handle)
        # 逻辑回归界面槽函数
        self.lr_penalty_comboBox.currentIndexChanged.connect(self.lr_penalty_handle)
        self.lr_solver_comboBox.currentIndexChanged.connect(self.lr_solver_handle)
        # knn界面槽函数
        self.knn_weights_comboBox.currentIndexChanged.connect(self.knn_weights_handle)
        self.knn_p_comboBox.currentIndexChanged.connect(self.knn_p_handle)
        # tree界面槽函数
        self.tree_criterion_comboBox.currentIndexChanged.connect(self.tree_criterion_handle)
        self.tree_splitter_comboBox.currentIndexChanged.connect(self.tree_splitter_handle)
        # guass界面槽函数
        self.guass_mode_comboBox.currentIndexChanged.connect(self.guass_mode_handle)
        # svm界面槽函数
        self.svm_kernel_comboBox.currentIndexChanged.connect(self.svm_kernel_handle)
        # 模型操作槽函数
        self.model_save_but.clicked.connect(self.model_para_save_but_handle)
        self.model_start_now_but.clicked.connect(self.model_start_now_but_handle)
        self.model_start_all_but.clicked.connect(self.model_start_all_but_handle)
        self.delete_model_but.clicked.connect(self.delete_model_but_handle)
        # 模型评估槽函数
        self.model_assess_but.triggered.connect(self.model_assess_but_handle)
        self.model_trained_but.clicked.connect(self.model_trained_but_handle)
        self.model_prepage_but.clicked.connect(self.model_prepage_but_handle)
        self.model_nextpage_but.clicked.connect(self.model_nextpage_but_handle)
        self.graphic_edit_but.clicked.connect(self.graphic_edit_but_handle)
        self.model_predict_but.clicked.connect(self.model_predict_but_handle)
        self.model_export_but.clicked.connect(self.model_export_but_handle)

    def combobox_additem(self):
        """
        combobox文本初始化
        :return:
        """
        # 加载数据界面的combobox的Item
        # self.load_data_select_model_combobox.addItems(['分类', '回归', '聚类'])
        self.load_data_select_model_combobox.addItems(['分类'])
        self.load_data_select_spilt_combobox.addItems(['train=0.6', 'train=0.7', 'train=0.8', 'train=0.9'])
        # self.code_mode_select_comboBox.addItems(['从0开始编码', '从1开始编码', '独热编码'])
        self.code_mode_select_comboBox.addItems(['从0开始编码', '从1开始编码'])
        # PCA界面的combobox的Item
        self.pca_mode_comboBox.addItems(["PCA", "KPCA", "IPCA"])
        self.pca_whiten_comboBox.addItems(["True", "False"])
        self.pca_svd_comboBox.addItems(["auto", "full", "arpack", "randomized"])
        self.kpca_kernel_comboBox.addItems(["linear", "poly", "rbf", "sigmoid", "cosine", "precomputed"])
        self.ipca_whiten_comboBox.addItems(["True", "False"])
        self.equal_mode_combobox.addItems(["None", "Undersampling", "Oversampling"])
        # 模型选择的combobox的Item
        self.model_select_combobox.addItem('LogisticRegression')
        self.model_select_combobox.addItem('Knn')
        self.model_select_combobox.addItem('Decision Tree')
        self.model_select_combobox.addItem('Naive Bayes')
        self.model_select_combobox.addItem('SVM')
        self.model_select_combobox.addItem('Random Forest')
        # 模型参数界面的combobox的Item
        self.lr_process_comboBox.addItems(["None", "Standard", "MinMax"])
        self.lr_penalty_comboBox.addItems(["l1", "l2"])
        self.lr_solver_comboBox.addItems(["liblinear", "saga"])
        self.knn_process_comboBox.addItems(["None", "Standard", "MinMax"])
        self.knn_weights_comboBox.addItems(["uniform", "distance"])
        self.knn_p_comboBox.addItems(["1", "2", "3", "4", "5"])
        self.tree_process_comboBox.addItems(["None", "Standard", "MinMax"])
        self.tree_criterion_comboBox.addItems(["gini", "entropy"])
        self.tree_splitter_comboBox.addItems(["best", "random"])
        self.guass_process_comboBox.addItems(["None", "Standard", "MinMax"])
        self.guass_mode_comboBox.addItems(["GaussianNB", "MultinomialNB", "BernoulliNB"])
        self.svm_process_comboBox.addItems(["None", "Standard", "MinMax"])
        self.svm_kernel_comboBox.addItems(["rbf", "linear", "poly", "sigmoid"])
        self.forest_process_comboBox.addItems(["None", "Standard", "MinMax"])

    # 数据导入函数
    def load_data_but_clicked_handle(self):
        """
        加载数据按钮逻辑
        :return:
        """
        self.total_stack.setCurrentIndex(0)
        filename, _ = QFileDialog.getOpenFileName(self, '选择文件', '', '*.csv;;*.xlsx')
        if not filename:
            pass  # 防止没有选择直接关闭导致程序崩溃
        else:
            try:
                # 判断文件类型
                if filename.split('.')[-1] == 'csv':
                    copyfile(filename, './temp/data_temp.csv')
                    self.ori_data = pd.read_csv('./temp/data_temp.csv')
                elif filename.split('.')[-1] == 'xlsx':
                    copyfile(filename, './temp/data_temp.xlsx')
                    self.ori_data = pd.read_excel('./temp/data_temp.xlsx')
            except IOError as e:
                print("Unable to copy file. %s" % e)
                exit(1)
            else:
                # 二次导入时重置标志位
                self.load_data_flag = False
                self.str_flag = True
                self.fea_analyzed_flag = False
                self.pca_analyzed_flag = False
                self.equal_index = 0
                # 二次导入时清空部分数据
                self.code_name_index_lists = []
                self.code_name_lists = []
                self.code_categorical_lists = []
                self.code_mode_lists = []

                self.model_code_name_lists = []
                self.model_code_categorical_lists = []
                self.model_code_mode_lists = []
                self.item_list = []
                self.model_process_lists = []
                self.x_train_list = []
                self.x_test_list = []
                self.y_train_list = []
                self.y_test_list = []
                self.model_para_list = []
                self.trained_model_list = []
                self.model_check_list = []

                self.code_data_list.clear()
                self.model_list.clear()
                # 创建一个标准模型
                self.load_data_model = QStandardItemModel()
                self.load_data_model.clear()  # 二次加载时清空原来的
                # 设置表头标签
                self.load_data_model.setHorizontalHeaderLabels(list(self.ori_data))
                # 提交项
                for i in range(self.ori_data.shape[0]):
                    temp_list = []
                    for j in range(self.ori_data.shape[1]):
                        temp_list.append(QStandardItem(str(self.ori_data.iloc[i, j])))
                    self.load_data_model.appendRow(temp_list)
                self.load_data_table.setModel(self.load_data_model)
                # 给标签选择Combobox添加项
                self.load_data_select_target_combobox.clear()  # 二次加载时清空原来的
                self.load_data_select_target_combobox.addItems(list(self.ori_data))
                # 双击表格的项可以对该项的数据进行修改
                self.load_data_table_select_mode = self.load_data_table.selectionModel()
                self.load_data_table.doubleClicked.connect(self.double_click)
                self.data_change_flag = 0

    def sure_data_but_handle(self):
        """
        数据导入确认按钮
        :return:
        """
        if self.load_data_select_target_combobox.count() <= 0:  # 判断是否已经导入数据
            QMessageBox.warning(self, "提示", "请先导入数据")
        else:
            # 获取选中的行和列
            if str(self.ori_data[
                       self.ori_data.columns[self.load_data_select_target_combobox.currentIndex()]].dtype) == 'object':
                QMessageBox.warning(self, "提示", "标签为字符型，请先编码或重新选择")
            else:
                selected_col = self.load_data_table.selectionModel().selectedColumns()
                selected_row = self.load_data_table.selectionModel().selectedRows()
                temp_col = []
                temp_row = []
                for i in selected_col:
                    if i.column() != self.load_data_select_target_combobox.currentIndex():
                        temp_col.append(i.column())
                for i in selected_row:
                    temp_row.append(i.row())
                temp_col.sort()
                temp_row.sort()
                # 用选中的行和列生成新的row_data
                if len(temp_col) == 0 and len(temp_row) == 0:
                    self.row_data = self.ori_data.drop(
                        self.ori_data.columns[[self.load_data_select_target_combobox.currentIndex()]], axis=1)
                elif len(temp_row) == 0:
                    self.row_data = self.ori_data.iloc[:, temp_col]
                elif len(temp_col) == 0:
                    self.row_data = self.ori_data.drop(
                        self.ori_data.columns[[self.load_data_select_target_combobox.currentIndex()]], axis=1)
                    self.row_data = self.row_data.iloc[temp_row, :]
                else:
                    self.row_data = self.ori_data.iloc[temp_row, temp_col]
                # 保存row_data及标签
                self.row_data_col = list(self.row_data)  # row_data的列名
                self.target = np.array(self.ori_data.iloc[:, self.load_data_select_target_combobox.currentIndex()])
                self.target = self.target.astype(int)
                lens = len(set(self.target))
                self.labels = [i for i in range(lens)]
                self.processed_data = self.row_data
                self.load_data_flag = True  # 数据已导入
                # 切换预处理stack的编码界面
                self.total_stack.setCurrentIndex(1)
                self.process_select_stack.setCurrentIndex(2)
                self.process_table_flag = 0
                # 为编码界面的编码项选择combobox添加Item
                self.code_data_name_comboBox.clear()  # 二次加载时清空原来的
                names = self.row_data.columns
                self.code_data_name_comboBox.addItems(names)
                # 为预处理界面的编码表格添加项
                self.code_mode = QStandardItemModel()
                self.code_mode.clear()  # 二次加载时清空原来的
                self.code_mode.setVerticalHeaderLabels(list(self.row_data))
                for i in range(self.row_data.shape[0]):
                    temp_list = []
                    for j in range(self.row_data.shape[1]):
                        temp_list.append(QStandardItem(str(self.row_data.iloc[i, j])))
                    self.code_mode.appendColumn(temp_list)
                self.process_table.setModel(self.code_mode)
                # 判断数据是否含有字符
                cols = self.processed_data.columns
                for col in cols:
                    if str(self.processed_data[col].dtype) == 'object':
                        self.str_flag = True
                        break
                    else:
                        self.str_flag = False

    # 特征选择函数
    def select_feature_but_handle(self):
        """
        特征选择按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif self.str_flag is True:
            QMessageBox.warning(self, "提示", "存在字符型数据，请先进行编码")
        else:
            # 跳转到预处理stack的特征选择界面
            self.total_stack.setCurrentIndex(1)
            self.process_select_stack.setCurrentIndex(0)
            self.process_table_flag = 0  # 表格数据导出状态

    def start_fea_select_but_handle(self):
        """
        开始进行特征分析按钮逻辑
        :return:
        """
        if len(self.feature_n_lineEdit.text()) > 0 and len(self.feature_max_depth_lineEdit.text()) > 0:
            if self.feature_n_lineEdit.text()[0] == '0' or self.feature_max_depth_lineEdit.text()[0] == '0':
                QMessageBox.warning(self, "提示", "请输入有效参数")
            else:
                self.select_feature_data = self.processed_data
                # 是否进行数据标准化
                if self.feature_standard_checkBox.isChecked():
                    scaler = StandardScaler()
                    data_scaler = scaler.fit_transform(self.select_feature_data)
                else:
                    data_scaler = self.select_feature_data
                # 分割数据并训练
                x_train, x_test, y_train, y_test = train_test_split(data_scaler, self.target,
                                                                    train_size=self.load_data_split_rate)
                self.forest = RandomForestClassifier(n_estimators=int(self.feature_n_lineEdit.text()), random_state=0,
                                                     n_jobs=-1, max_depth=int(self.feature_max_depth_lineEdit.text()))
                self.forest.fit(x_train, y_train)
                print(self.forest.score(x_test, y_test))
                # 为特征选择表格添加项
                self.fea_select_model = QStandardItemModel()
                self.fea_select_model.clear()  # 二次加载时清空原来的
                self.fea_select_model.setHorizontalHeaderLabels(['特征', '重要性', '', '', '', ''])
                for i in range(self.select_feature_data.shape[1]):
                    self.fea_select_model.appendRow([QStandardItem(list(self.select_feature_data)[i]),
                                                     QStandardItem(str(self.forest.feature_importances_[i]))])
                if self.select_feature_data.shape[1] < 30:
                    for i in range(30 - self.select_feature_data.shape[1]):
                        self.fea_select_model.appendRow([QStandardItem(''), QStandardItem('')])
                self.process_table.setModel(self.fea_select_model)
                self.process_table.resizeColumnToContents(1)  # 设置表格的宽度为自动
                # 为下一步特征选择设置提示文本和标志位
                self.feature_th_lineedit.setPlaceholderText("请输入%.3f~%.3f之间的数" % (
                    min(self.forest.feature_importances_) + 0.001, max(self.forest.feature_importances_) - 0.001))
                self.fea_analyzed_flag = True  # 可以进行特征选择

    def feature_th_sure_but_handle(self):
        """
        确定进行特征选择按钮逻辑
        :return:
        """
        if self.fea_analyzed_flag is False:
            QMessageBox.warning(self, "提示", "请先进行重要性分析")
        else:
            if len(self.feature_th_lineedit.text()) > 0:
                try:
                    th = float(self.feature_th_lineedit.text())
                except Exception as e:
                    print(e)
                    QMessageBox.warning(self, "提示", "请输入有效参数")
                else:
                    if min(self.forest.feature_importances_) + 0.001 <= th <= max(
                            self.forest.feature_importances_) - 0.001:
                        # 将小于阈值的列清除
                        fea_drop_list = []
                        fea_select_list = []
                        for i in range(len(self.forest.feature_importances_)):
                            if self.forest.feature_importances_[i] < th:
                                fea_drop_list.append(self.row_data_col[i])
                            else:
                                fea_select_list.append(self.row_data_col[i])
                        self.select_feature_data.drop(columns=fea_drop_list, inplace=True)
                        # 重新加载特征选择表格
                        self.fea_select_model.clear()
                        self.fea_select_model.setVerticalHeaderLabels(list(self.select_feature_data))
                        for i in range(self.select_feature_data.shape[0]):
                            temp_list = []
                            for j in range(self.select_feature_data.shape[1]):
                                temp_list.append(QStandardItem(str(self.select_feature_data.iloc[i, j])))
                            self.fea_select_model.appendColumn(temp_list)
                        self.process_table.setModel(self.fea_select_model)
                        # 更新处理好的数据
                        self.processed_data = self.select_feature_data
                        # 设置标志位
                        self.process_table_flag = 2
                        self.fea_analyzed_flag = False
                    else:
                        QMessageBox.warning(self, "提示", "请输入有效参数")

    # 编码界面的槽函数
    def encode_but_handle(self):
        """
        顶部编码按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        else:
            # 切换为预处理stack的编码界面
            self.total_stack.setCurrentIndex(1)
            self.process_select_stack.setCurrentIndex(2)
            self.code_data_list.clear()          # 二次加载时清空原来的
            self.code_data_name_comboBox.clear()
            names = self.processed_data.columns  # 添加新的item
            self.code_data_name_comboBox.addItems(names)
            self.process_table_flag = 0  # 表格此时不可导出

    def code_data_add_but_handle(self):
        """
        确定编码数据列按钮
        :return:
        """
        if self.code_data_name_comboBox.currentIndex() not in self.code_name_index_lists:  # 如果不在lists内则添加
            self.code_name_index_lists.append(self.code_data_name_comboBox.currentIndex())
            self.code_data_list.addItem(str(self.row_data.columns[self.code_data_name_comboBox.currentIndex()]))

    def code_data_del_but_handle(self):
        """
        删除编码数据列按钮
        :return:
        """
        if len(self.code_name_index_lists) > 0 and self.code_data_list.currentRow() >= 0:
            self.code_data_list.takeItem(self.code_data_list.currentRow())
            self.code_name_index_lists.pop(self.code_data_list.currentRow())

    def code_sure_but_handle(self):
        """
        确定编码按钮
        :return:
        """
        if len(self.code_name_index_lists) > 0:
            self.code_after_data = self.processed_data
            # 根据不同模式对选中的数据列进行编码
            colName = self.code_after_data.columns[self.code_name_index_lists]
            for name in colName:
                if name not in self.code_name_lists:  # 如果未被编码过
                    if self.code_mode_select_comboBox.currentIndex() == 0:  # 从0开始编码
                        categorical = pd.Categorical(self.code_after_data[name])
                        self.code_after_data[name] = categorical.codes
                        self.code_mode_lists.append(0)
                    elif self.code_mode_select_comboBox.currentIndex() == 1:  # 从1开始编码
                        categorical = pd.Categorical(self.code_after_data[name])
                        self.code_after_data[name] = categorical.codes + 1
                        self.code_mode_lists.append(1)
                    self.code_name_lists.append(name)
                    self.code_categorical_lists.append(categorical.categories)
                    # 刷新编码表格
                    self.code_mode.clear()  # 清空原来数据
                    self.code_mode.setVerticalHeaderLabels(list(self.code_after_data))
                    for i in range(self.code_after_data.shape[0]):
                        temp_list = []
                        for j in range(self.code_after_data.shape[1]):
                            temp_list.append(QStandardItem(str(self.code_after_data.iloc[i, j])))
                        self.code_mode.appendColumn(temp_list)
                    self.process_table.setModel(self.code_mode)
                    # 刷新编码后的数据
                    self.processed_data = self.code_after_data
                    self.process_table_flag = 1  # 表格可以导出
                    # 判断数据是否含有字符
                    cols = self.processed_data.columns
                    for col in cols:
                        if str(self.processed_data[col].dtype) == 'object':
                            self.str_flag = True
                            break
                        else:
                            self.str_flag = False

    # PCA界面槽函数
    def PCA_but_handle(self):
        """
        PCA顶部按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif self.str_flag is True:
            QMessageBox.warning(self, "提示", "存在字符型数据，请先进行编码")
        else:
            # 切换到预处理stack的PCA界面
            self.total_stack.setCurrentIndex(1)
            self.process_select_stack.setCurrentIndex(3)
            self.process_table_flag = 0  # 该表格不能导出
            self.pca_analyzed_flag = False  # 未进行pca分析
            # 更新数据并设置提示
            self.pca_data = self.processed_data
            self.pca_n_lineEdit.setPlaceholderText("请输入0~%d的整数或0~1的小数或mle" % (self.pca_data.shape[1] - 1))
            self.kpca_n_lineEdit.setPlaceholderText("请输入0~%d的整数" % (self.pca_data.shape[1] - 1))
            self.ipca_n_lineEdit.setPlaceholderText("请输入0~%d的整数" % (self.pca_data.shape[1] - 1))
            self.ipca_batch_lineEdit.setPlaceholderText("请输入大于0的整数")

    def pca_whiten_handle(self, i):
        """
        pca_whiten_combobox逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.pca_whiten_select = True
        else:
            self.pca_whiten_select = False

    def pca_svd_handle(self, i):
        """
        pca_svd_combobox逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.pca_svd_select = 'auto'
        elif i == 1:
            self.pca_svd_select = 'full'
        elif i == 2:
            self.pca_svd_select = 'arpack'
        else:
            self.pca_svd_select = 'randomized'

    def kpca_kernel_handle(self, i):
        """
        kpca_kernel_combobox逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.kpca_kernel_select = 'linear'
        elif i == 1:
            self.kpca_kernel_select = 'poly'
        elif i == 2:
            self.kpca_kernel_select = 'rbf'
        elif i == 3:
            self.kpca_kernel_select = 'sigmoid'
        elif i == 4:
            self.kpca_kernel_select = 'cosine'
        elif i == 5:
            self.kpca_kernel_select = 'precomputed'

    def ipca_whiten_handle(self, i):
        """
        ipca_whiten_comboboxl逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.ipca_whiten_select = True
        else:
            self.ipca_whiten_select = False

    def pca_start_but_handle(self):
        """
        开始主成分分析按钮
        :return:
        """
        self.pca_data = self.processed_data  # 更新数据
        # PCA模式
        if self.pca_mode_comboBox.currentIndex() == 0:
            if len(self.pca_n_lineEdit.text()) > 0:
                # 判断n_component参数的输入是否合理
                pca_flag = 0
                if '.' in self.pca_n_lineEdit.text():  # 小数判断
                    try:
                        n_component = float(self.pca_n_lineEdit.text())
                    except Exception as e:
                        print(e)
                    else:
                        if 0 < n_component < 1:
                            pca_flag = 1
                elif self.pca_n_lineEdit.text() == 'mle':  # mle判断
                    n_component = 'mle'
                    pca_flag = 1
                else:
                    try:
                        n_component = int(self.pca_n_lineEdit.text())  # 整数判断
                    except Exception as e:
                        print(e)
                    else:
                        if 0 < n_component < self.pca_data.shape[1]:
                            pca_flag = 1
                # 如果合理执行一下语句
                if pca_flag == 1:
                    # pca为全选，pca1为用户的设置，方便比较
                    pca = PCA(n_components=self.pca_data.shape[1], whiten=self.pca_whiten_select,
                              svd_solver=self.pca_svd_select)
                    pca.fit(self.pca_data)
                    pca1 = PCA(n_components=n_component, whiten=self.pca_whiten_select, svd_solver=self.pca_svd_select)
                    pca1.fit(self.pca_data)
                    # 刷新PCA表格
                    explained_variance_ = []
                    for i in range(len(pca1.explained_variance_)):
                        explained_variance_.append(int(pca1.explained_variance_[i] * 100))
                    self.pca_model = QStandardItemModel()
                    self.pca_model.clear()  # 二次加载先清除原先的数据
                    self.pca_model.setHorizontalHeaderLabels(['特征', '方差值', '所占比例', '是否保留', '', ''])
                    self.pca_drop_label = []
                    for i in range(self.pca_data.shape[1]):
                        if int(pca.explained_variance_[i] * 100) in explained_variance_:
                            self.pca_model.appendRow(
                                [QStandardItem(list(self.pca_data)[i]), QStandardItem(str(pca.explained_variance_[i])),
                                 QStandardItem(str(pca.explained_variance_ratio_[i])), QStandardItem('保留')])
                        else:
                            self.pca_model.appendRow(
                                [QStandardItem(list(self.pca_data)[i]), QStandardItem(str(pca.explained_variance_[i])),
                                 QStandardItem(str(pca.explained_variance_ratio_[i])), QStandardItem('不保留')])
                            self.pca_drop_label.append(list(self.pca_data)[i])
                    if self.pca_data.shape[1] < 30:
                        for i in range(30 - self.pca_data.shape[1]):
                            self.pca_model.appendRow(
                                [QStandardItem(''), QStandardItem(''), QStandardItem(''), QStandardItem('')])
                    self.process_table.setModel(self.pca_model)
                # 如果不合理进行提示
                else:
                    QMessageBox.warning(self, "提示", "请输入有效参数")
        # KPCA模式
        elif self.pca_mode_comboBox.currentIndex() == 1:
            if len(self.kpca_n_lineEdit.text()) > 0:
                # 判断n_component是否合理
                if self.kpca_n_lineEdit.text()[0] == '0':
                    QMessageBox.warning(self, "提示", "请输入有效参数")
                else:
                    n_component = int(self.kpca_n_lineEdit.text())
                    if n_component >= self.pca_data.shape[1]:
                        QMessageBox.warning(self, "提示", "请输入有效参数")
                    # 如果合理则执行以下语句
                    else:
                        # pca为全选，pca1为用户的设置，方便比较
                        pca = KernelPCA(n_components=self.pca_data.shape[1], kernel=self.kpca_kernel_select)
                        kpca_transform = pca.fit_transform(self.pca_data)
                        explained_variance_ = np.var(kpca_transform, axis=0)
                        explained_variance_ratio_ = explained_variance_ / np.sum(explained_variance_)
                        pca1 = KernelPCA(n_components=n_component, kernel=self.kpca_kernel_select)
                        kpca_transform1 = pca1.fit_transform(self.pca_data)
                        explained_variance1_ = np.var(kpca_transform1, axis=0)
                        # 刷新KPCA表格
                        for i in range(len(explained_variance1_)):
                            explained_variance1_[i] = int(explained_variance1_[i] * 100)
                        self.pca_model = QStandardItemModel()
                        self.pca_model.clear()  # 二次加载先清除原先的数据
                        self.pca_model.setHorizontalHeaderLabels(['特征', '方差值', '所占比例', '是否保留', '', ''])
                        self.pca_drop_label = []
                        for i in range(self.pca_data.shape[1]):
                            if int(explained_variance_[i] * 100) in explained_variance1_:
                                self.pca_model.appendRow(
                                    [QStandardItem(list(self.pca_data)[i]), QStandardItem(str(explained_variance_[i])),
                                     QStandardItem(str(explained_variance_ratio_[i])), QStandardItem('保留')])
                            else:
                                self.pca_model.appendRow(
                                    [QStandardItem(list(self.pca_data)[i]), QStandardItem(str(explained_variance_[i])),
                                     QStandardItem(str(explained_variance_ratio_[i])), QStandardItem('不保留')])
                                self.pca_drop_label.append(list(self.pca_data)[i])
                        if self.pca_data.shape[1] < 30:
                            for i in range(30 - self.pca_data.shape[1]):
                                self.pca_model.appendRow(
                                    [QStandardItem(''), QStandardItem(''), QStandardItem(''), QStandardItem('')])
                        self.process_table.setModel(self.pca_model)
        # IPCA模式
        elif self.pca_mode_comboBox.currentIndex() == 2:
            if len(self.ipca_n_lineEdit.text()) > 0 and len(self.ipca_batch_lineEdit.text()) > 0:
                # 判断n_component和batch_size参数是否合理
                if self.ipca_n_lineEdit.text()[0] == '0' and self.ipca_batch_lineEdit.text()[0] == '0':
                    QMessageBox.warning(self, "提示", "请输入有效参数")
                else:
                    n_component = int(self.ipca_n_lineEdit.text())
                    if n_component >= self.pca_data.shape[1]:
                        QMessageBox.warning(self, "提示", "请输入有效参数")
                    # 如果合理则执行以下语句
                    else:
                        # pca为全选，pca1为用户的设置，方便比较
                        batch = int(self.ipca_batch_lineEdit.text())
                        pca = IncrementalPCA(n_components=self.pca_data.shape[1], whiten=self.ipca_whiten_select,
                                             batch_size=batch)
                        pca.fit(self.pca_data)
                        pca1 = IncrementalPCA(n_components=n_component, whiten=self.ipca_whiten_select,
                                              batch_size=batch)
                        pca1.fit(self.pca_data)
                        explained_variance_ = []
                        # 刷新IPCA表格
                        for i in range(len(pca1.explained_variance_)):
                            explained_variance_.append(int(pca1.explained_variance_[i] * 100))
                        self.pca_model = QStandardItemModel()
                        self.pca_model.clear()  # 二次加载先清除原先的数据
                        self.pca_model.setHorizontalHeaderLabels(['特征', '方差值', '所占比例', '是否保留', '', ''])
                        self.pca_drop_label = []
                        for i in range(self.pca_data.shape[1]):
                            if int(pca.explained_variance_[i] * 100) in explained_variance_:
                                self.pca_model.appendRow(
                                    [QStandardItem(list(self.pca_data)[i]),
                                     QStandardItem(str(pca.explained_variance_[i])),
                                     QStandardItem(str(pca.explained_variance_ratio_[i])), QStandardItem('保留')])
                            else:
                                self.pca_model.appendRow(
                                    [QStandardItem(list(self.pca_data)[i]),
                                     QStandardItem(str(pca.explained_variance_[i])),
                                     QStandardItem(str(pca.explained_variance_ratio_[i])), QStandardItem('不保留')])
                                self.pca_drop_label.append(list(self.pca_data)[i])
                        if self.pca_data.shape[1] < 30:
                            for i in range(30 - self.pca_data.shape[1]):
                                self.pca_model.appendRow(
                                    [QStandardItem(''), QStandardItem(''), QStandardItem(''), QStandardItem('')])
                        self.process_table.setModel(self.pca_model)
                        self.process_table.resizeColumnToContents(2)
        self.pca_analyzed_flag = True  # 已进行pca分析

    def pca_sure_but_handle(self):
        """
        确定使用pca分析结果
        :return:
        """
        if self.pca_analyzed_flag is False:
            QMessageBox.warning(self, "提示", "请先进行pca分析")
        else:
            # 将pca分析后不符合要求的数据剔除
            self.pca_data.drop(columns=self.pca_drop_label, inplace=True)
            # 刷新PCA表格
            self.pca_model.clear()
            self.pca_model.setVerticalHeaderLabels(list(self.pca_data))
            for i in range(self.pca_data.shape[0]):
                temp_list = []
                for j in range(self.pca_data.shape[1]):
                    temp_list.append(QStandardItem(str(self.pca_data.iloc[i, j])))
                self.pca_model.appendColumn(temp_list)
            self.process_table.setModel(self.pca_model)
            # 更新pca分析后的数据
            self.processed_data = self.pca_data
            self.process_table_flag = 3  # 可以导出表格
            self.pca_analyzed_flag = False  # 1次pca分析只能点击一次确认按钮

    # 均衡化界面槽函数
    def equal_but_handle(self):
        """
        均衡化顶部按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif self.str_flag is True:
            QMessageBox.warning(self, "提示", "存在字符型数据，请先进行编码")
        else:
            # 切换为预处理stack的均衡化界面
            self.total_stack.setCurrentIndex(1)
            self.process_select_stack.setCurrentIndex(1)
            self.equal_index = 0  # 默认选择为不处理
            # 刷新相关的combobox控件的Item
            if self.equal_mode_combobox.currentIndex() == 0:
                self.equal_method_comboBox.clear()  # None
            if self.equal_mode_combobox.currentIndex() == 1:
                self.equal_method_comboBox.clear()  # 欠采样
                self.equal_method_comboBox.addItems(["Random Undersampling", "Cluster Centroids", "Tomek Links"])
            elif self.equal_mode_combobox.currentIndex() == 2:
                self.equal_method_comboBox.clear()  # 过采样
                self.equal_method_comboBox.addItems(["Random Oversampling", "SMOTE", "ADASYN"])

    def equal_mode_combobox_handle(self, i):
        """
        均衡化模式选择combobox切换逻辑
        :param i:
        :return:
        """
        if i == 0:  # None
            self.equal_method_comboBox.clear()
        elif i == 1:  # 欠采样
            self.equal_method_comboBox.clear()
            self.equal_method_comboBox.addItems(["Random Undersampling", "Cluster Centroids", "Tomek Links"])
        elif i == 2:  # 过采样
            self.equal_method_comboBox.clear()
            self.equal_method_comboBox.addItems(["Random Oversampling", "SMOTE", "ADASYN"])

    def equal_sure_but_handle(self):
        """
        确认进行均衡化处理按钮逻辑
        :return:
        """
        QMessageBox.warning(self, "提示", "操作成功，效果会在模型训练中体现")
        if self.equal_mode_combobox.currentIndex() == 0:
            self.equal_index = 0  # 不处理
        elif self.equal_mode_combobox.currentIndex() == 1:
            self.equal_index = 1 + self.equal_method_comboBox.currentIndex()  # 欠采样
        elif self.equal_mode_combobox.currentIndex() == 2:
            self.equal_index = 3 + self.equal_method_comboBox.currentIndex()  # 过采样

    def equal_oprate(self, x_train_row, y_train_row):
        """
        均衡化在模型训练中的操作
        :return:
        """
        # 根据不同具体模式对数据进行不同操作
        if self.equal_index == 0:  # 不处理
            x_train, y_train = x_train_row, y_train_row
        # 欠采样
        elif self.equal_index == 1:
            rus = RandomUnderSampler(random_state=42)
            x_train, y_train = rus.fit_resample(x_train_row, y_train_row)
        elif self.equal_index == 2:
            cc = ClusterCentroids(random_state=42)
            x_train, y_train = cc.fit_resample(x_train_row, y_train_row)
        elif self.equal_index == 3:
            tl = TomekLinks()
            x_train, y_train = tl.fit_resample(x_train_row, y_train_row)
        # 过采样
        elif self.equal_index == 4:
            ros = RandomOverSampler(random_state=42)
            x_train, y_train = ros.fit_resample(x_train_row, y_train_row)
        elif self.equal_index == 5:
            smote = SMOTE(random_state=42)
            x_train, y_train = smote.fit_resample(x_train_row, y_train_row)
        elif self.equal_index == 6:
            adasyn = ADASYN(random_state=42)
            x_train, y_train = adasyn.fit_resample(x_train_row, y_train_row)
        return x_train, y_train

    # 模型训练函数
    def model_select_combobox_handle(self, i):
        """
        模型选择combobox被激活时的逻辑
        :param i:
        :return:
        """

        # 自定义列表项对象
        class customQListWidgetItem(QListWidgetItem):
            def __init__(self, img_path, name, number):
                super().__init__()
                # 自定义item中的widget 用来显示自定义的内容
                self.item_widget = QWidget()
                # 设置widget的布局
                self.item_layout = QHBoxLayout()
                self.item_layout.setContentsMargins(0, 0, 0, 0)
                self.item_layout.setSpacing(0)
                self.item_widget.setLayout(self.item_layout)
                # 控件
                self.model_list_picture_label = QLabel()
                self.item_layout.addWidget(self.model_list_picture_label)

                self.model_list_name_layout = QtWidgets.QVBoxLayout()
                self.model_list_number_label = QLabel(number)
                self.model_list_name_layout.addWidget(self.model_list_number_label)
                self.mode_list_name_labl = QLabel(name)
                self.model_list_name_layout.addWidget(self.mode_list_name_labl)
                self.item_layout.addLayout(self.model_list_name_layout)

                self.model_list_inf_layout = QtWidgets.QVBoxLayout()
                self.model_list_inf_layout.setContentsMargins(80, -1, -1, -1)
                self.model_list_inf_progressBar = QProgressBar()
                sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)
                sizePolicy.setHorizontalStretch(0)
                sizePolicy.setVerticalStretch(0)
                sizePolicy.setHeightForWidth(self.model_list_inf_progressBar.sizePolicy().hasHeightForWidth())
                self.model_list_inf_progressBar.setSizePolicy(sizePolicy)
                self.model_list_inf_progressBar.setProperty("value", 0)
                self.model_list_inf_progressBar.setTextVisible(True)
                self.model_list_inf_progressBar.setOrientation(QtCore.Qt.Horizontal)
                self.model_list_inf_progressBar.setInvertedAppearance(False)
                self.model_list_inf_progressBar.setMaximum(1000)
                self.model_list_inf_progressBar.setStyleSheet(
                    "QProgressBar { border: 2px solid grey; border-radius: 5px; color: rgb(20,20,20);  background-color: #FFFFFF; text-align: center;}QProgressBar::chunk {background-color: rgb(100,200,200); border-radius: 10px; margin: 0.1px;  width: 1px;}")
                self.model_list_inf_layout.addWidget(self.model_list_inf_progressBar)
                self.model_list_inf_label = QLabel('未训练/未保存')
                self.model_list_inf_label.setAlignment(
                    QtCore.Qt.AlignRight | QtCore.Qt.AlignTrailing | QtCore.Qt.AlignVCenter)
                self.model_list_inf_layout.addWidget(self.model_list_inf_label)
                self.item_layout.addLayout(self.model_list_inf_layout)
                # 设置图像源 和 图像大小
                self.model_list_picture_label.setPixmap(QPixmap(img_path).scaled(80, 70))
                # 设置布局
                self.item_layout.setStretch(0, 1)
                self.item_layout.setStretch(1, 1)
                self.item_layout.setStretch(2, 3)
                # 设置自定义的QListWidgetItem的sizeHint，不然无法显示
                self.setSizeHint(self.item_widget.sizeHint())

        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif self.str_flag is True:
            QMessageBox.warning(self, "提示", "存在字符型数据，请先进行编码")
        else:
            # 设置当前索引为新增模型
            self.item_index = len(self.item_list)
            # 在列表中为新增模型添加项
            number = "NO.{}".format(len(self.item_list) + 1)
            item = customQListWidgetItem(self.model_img_path[i], self.model_name_list[i], number)
            self.model_list.addItem(item)
            self.model_list.setItemWidget(item, item.item_widget)
            # 将该itme添加到item_list中,方便之后的操作
            self.item_list.append(item)
            self.model_batch_handle(0)  # 批量添加None
            # 切换为模型stack的模型选择satck的第0页，模型按钮stack的第0页
            self.total_stack.setCurrentIndex(2)
            self.model_page_select_stack.setCurrentIndex(0)
            self.model_page_but_stack.setCurrentIndex(0)
            # 根据不同模型切换为不同的模型训练界面
            if self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Logist':
                self.model_train_select_stack.setCurrentIndex(0)
            elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Knn':
                self.model_train_select_stack.setCurrentIndex(1)
            elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Tree':
                self.model_train_select_stack.setCurrentIndex(2)
            elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Bayes':
                self.model_train_select_stack.setCurrentIndex(3)
            elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'SVM':
                self.model_train_select_stack.setCurrentIndex(4)
            elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Forest':
                self.model_train_select_stack.setCurrentIndex(5)

    def model_list_handle(self):
        """
        列表中的项被选择时的逻辑
        :return:
        """
        self.item_index = self.model_list.currentRow()  # 更新当前索引
        # 模型选择satck的第0页，模型按钮stack的第0页
        self.model_page_select_stack.setCurrentIndex(0)
        self.model_page_but_stack.setCurrentIndex(0)
        # 根据不同模型切换为不同的模型训练界面
        if self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Logist':
            self.model_train_select_stack.setCurrentIndex(0)
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Knn':
            self.model_train_select_stack.setCurrentIndex(1)
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Tree':
            self.model_train_select_stack.setCurrentIndex(2)
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Bayes':
            self.model_train_select_stack.setCurrentIndex(3)
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'SVM':
            self.model_train_select_stack.setCurrentIndex(4)
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Forest':
            self.model_train_select_stack.setCurrentIndex(5)

    def model_para_save_but_handle(self):
        """
        保存模型按钮逻辑
        :return:
        """
        if self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Logist':
            self.lr_model_save()
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Knn':
            self.knn_model_save()
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Tree':
            self.tree_model_save()
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Bayes':
            self.guass_model_save()
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'SVM':
            self.svm_model_save()
        elif self.model_list.item(self.item_index).mode_list_name_labl.text() == 'Forest':
            self.forest_model_save()

    def model_start_now_but_handle(self):
        """
        模型开始训练按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        else:
            if self.model_para_list[self.item_index] is None:
                QMessageBox.warning(self, "提示", "请先保存模型")
            else:
                # try:
                #     model = self.model_para_list[self.item_index]
                #     model.fit(self.x_train_list[self.item_index], self.y_train_list[self.item_index])
                # except Exception as e:
                #     print(e)
                # else:
                # 训练模型
                model = self.model_para_list[self.item_index]
                model.fit(self.x_train_list[self.item_index], self.y_train_list[self.item_index])
                # 网格搜索执行操作
                if self.model_check_list[self.item_index] is True:
                    self.trained_model_list[self.item_index] = model.best_estimator_  # 存储已训练的最佳模型
                    score = float(model.best_estimator_.score(self.x_test_list[self.item_index],
                                                              self.y_test_list[self.item_index]) * 100)
                    self.model_list.item(self.item_index).model_list_inf_progressBar.setFormat("%.01f %%" % score)
                    self.model_list.item(self.item_index).model_list_inf_progressBar.setValue(int(score * 10))
                # 正常参数选择执行的操作
                else:
                    self.trained_model_list[self.item_index] = model  # 存储已训练的模型
                    score = float(
                        model.score(self.x_test_list[self.item_index], self.y_test_list[self.item_index]) * 100)
                    self.model_list.item(self.item_index).model_list_inf_progressBar.setFormat("%.01f %%" % score)
                    self.model_list.item(self.item_index).model_list_inf_progressBar.setValue(int(score * 10))
                # 更新列表项的文字
                self.model_list.item(self.item_index).model_list_inf_label.setText('已训练/已保存')
                # 产生评估数据，并切换为模型stack的模型选择satck的第0页，模型按钮stack的第0页
                self.assess_data_generate()
                self.total_stack.setCurrentIndex(2)
                self.model_page_select_stack.setCurrentIndex(1)
                self.model_page_but_stack.setCurrentIndex(1)
                # 初始化页数
                self.assess_page_now = 0
                self.assess_page_total = 1
                self.model_page_label.setText("共{}页/第{}页".format(self.assess_page_total + 1, self.assess_page_now + 1))
                self.model_assess_select_stack.setCurrentIndex(self.assess_page_now)
                # 模型评估图形列表初始化
                self.assess_graphic_list = [None, None]

    def model_start_all_but_handle(self):
        """
        所有模型开始训练按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        else:
            all_flag = False
            for i in range(self.model_list.count()):
                if self.model_para_list[i] is not None:
                    all_flag = True
                    break
            if all_flag is False:
                QMessageBox.warning(self, "提示", "请先保存模型参数")
            else:
                for i in range(self.model_list.count()):
                    if self.model_para_list[i] is not None:
                        self.item_index = i
                        # 训练模型
                        model = self.model_para_list[self.item_index]
                        model.fit(self.x_train_list[self.item_index], self.y_train_list[self.item_index])
                        # 网格搜索执行操作
                        if self.model_check_list[self.item_index] is True:
                            self.trained_model_list[self.item_index] = model.best_estimator_  # 存储已训练的最佳模型
                            score = float(model.best_estimator_.score(self.x_test_list[self.item_index],
                                                                      self.y_test_list[self.item_index]) * 100)
                            self.model_list.item(self.item_index).model_list_inf_progressBar.setFormat(
                                "%.01f %%" % score)
                            self.model_list.item(self.item_index).model_list_inf_progressBar.setValue(int(score * 10))
                        # 正常参数选择执行的操作
                        else:
                            self.trained_model_list[self.item_index] = model  # 存储已训练的模型
                            score = float(
                                model.score(self.x_test_list[self.item_index], self.y_test_list[self.item_index]) * 100)
                            self.model_list.item(self.item_index).model_list_inf_progressBar.setFormat(
                                "%.01f %%" % score)
                            self.model_list.item(self.item_index).model_list_inf_progressBar.setValue(int(score * 10))
                        # 更新列表项的文字
                        self.model_list.item(self.item_index).model_list_inf_label.setText('已训练/已保存')
                # 产生评估数据，并切换为模型stack的模型选择satck的第0页，模型按钮stack的第0页
                self.assess_data_generate()
                self.total_stack.setCurrentIndex(2)
                self.model_page_select_stack.setCurrentIndex(1)
                self.model_page_but_stack.setCurrentIndex(1)
                # 初始化页数
                self.assess_page_now = 0
                self.assess_page_total = 1
                self.model_page_label.setText(
                    "共{}页/第{}页".format(self.assess_page_total + 1, self.assess_page_now + 1))
                self.model_assess_select_stack.setCurrentIndex(self.assess_page_now)
                # 模型评估图形列表初始化
                self.assess_graphic_list = [None, None]

    def delete_model_but_handle(self):
        """
        删除模型按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif self.model_list.currentRow() == -1:
            QMessageBox.warning(self, "提示", "请先选中或创建模型")
        else:
            temp_row = self.model_list.currentRow()
            # 删除该模型相关数据
            self.model_batch_handle(2)
            self.item_list.pop(temp_row)
            self.model_list.takeItem(temp_row)
            # 模型列表重新编号
            for i in range(len(self.model_list)):
                self.model_list.item(i).model_list_number_label.setText('NO.{}'.format(i + 1))
            # 在列表中选中上一个模型并在界面上显示上一个模型的参数界面
            self.model_list.setCurrentItem(self.model_list.item(temp_row - 1))
            self.item_index = self.model_list.currentRow()
            self.model_page_select_stack.setCurrentIndex(0)
            self.model_page_but_stack.setCurrentIndex(0)
            if temp_row - 1 > -1:
                if self.model_list.item(temp_row - 1).mode_list_name_labl.text() == 'Logist':
                    self.model_train_select_stack.setCurrentIndex(0)
                elif self.model_list.item(temp_row - 1).mode_list_name_labl.text() == 'Knn':
                    self.model_train_select_stack.setCurrentIndex(1)
                elif self.model_list.item(temp_row - 1).mode_list_name_labl.text() == 'Tree':
                    self.model_train_select_stack.setCurrentIndex(2)
                elif self.model_list.item(temp_row - 1).mode_list_name_labl.text() == 'Bayes':
                    self.model_train_select_stack.setCurrentIndex(3)
                elif self.model_list.item(temp_row - 1).mode_list_name_labl.text() == 'SVM':
                    self.model_train_select_stack.setCurrentIndex(4)
                elif self.model_list.item(temp_row - 1).mode_list_name_labl.text() == 'Forest':
                    self.model_train_select_stack.setCurrentIndex(5)
            else:
                self.model_page_but_stack.setCurrentIndex(2)
                self.model_train_select_stack.setCurrentIndex(6)  # 否则显示空界面

    def lr_penalty_handle(self, i):
        """
        lr_penalty_combobox逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.lr_penalty_select = 'l1'
            self.lr_solver_comboBox.clear()
            self.lr_solver_comboBox.addItems(["liblinear", "saga"])
        else:
            self.lr_penalty_select = 'l2'
            self.lr_solver_comboBox.clear()
            self.lr_solver_comboBox.addItems(["liblinear", "lbfgs", "newton-cg", "sag"])

    def lr_solver_handle(self, i):
        """
        lr_solver_combobox逻辑
        :param i:
        :return:
        """
        if self.lr_penalty_select == 'l1':
            if i == 0:
                self.lr_solver_select = 'liblinear'
            elif i == 1:
                self.lr_solver_select = 'saga'
        elif self.lr_penalty_select == 'l2':
            if i == 0:
                self.lr_solver_select = 'liblinear'
            elif i == 1:
                self.lr_solver_select = 'lbfgs'
            elif i == 2:
                self.lr_solver_select = 'newton-cg'
            elif i == 3:
                self.lr_solver_select = 'sag'

    def lr_model_save(self):
        """
        逻辑回归模型保存逻辑
        :return:
        """
        if len(self.lr_max_iter_lineEdit.text()) > 0 or self.lr_grid_search_checkBox.isChecked():
            if self.lr_max_iter_lineEdit.text()[0] == '0' and self.lr_grid_search_checkBox.isChecked() == 0:
                QMessageBox.warning(self, "提示", "请输入有效参数")
            else:
                # 不同数据处理进行的不同操作
                if self.lr_process_comboBox.currentIndex() == 0:
                    self.model_data = self.processed_data
                elif self.lr_process_comboBox.currentIndex() == 1:
                    scaler = StandardScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                elif self.lr_process_comboBox.currentIndex() == 2:
                    scaler = MinMaxScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                # 划分数据并进行均衡化处理
                x_train_row, x_test, y_train_row, y_test = train_test_split(self.model_data, self.target,
                                                                            train_size=self.load_data_split_rate)
                x_train, y_train = self.equal_oprate(x_train_row, y_train_row)
                # 网格搜索执行的操作
                if self.lr_grid_search_checkBox.isChecked():
                    temp_model = LogisticRegression()
                    para_grid = [
                        {'penalty': ['l2'], 'solver': ["liblinear", "lbfgs", "newton-cg", "sag"], 'max_iter': [1000]},
                        {'penalty': ['l1'], 'solver': ["liblinear", "saga"], 'max_iter': [1000]}]
                    model = GridSearchCV(temp_model, para_grid)
                    self.model_check_list[self.item_index] = True
                # 正常参数执行的操作
                else:
                    model = LogisticRegression(max_iter=int(self.lr_max_iter_lineEdit.text()),
                                               penalty=self.lr_penalty_select, solver=self.lr_solver_select)
                # 将模型相关参数保存
                self.model_batch_handle(1, model, x_train, x_test, y_train, y_test,
                                        self.lr_process_comboBox.currentIndex())
                self.model_list.item(self.item_index).model_list_inf_label.setText('未训练/已保存')  # 更新列表项的文字

    def knn_weights_handle(self, i):
        """
        knn_weights_combobox逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.knn_weights_select = "uniform"
        elif i == 1:
            self.knn_weights_select = "distance"

    def knn_p_handle(self, i):
        """
        knn_p_combobox逻辑
        :param i:
        :return:
        """
        self.knn_p_select = i + 1

    def knn_model_save(self):
        """
        knn模型保存逻辑
        :return:
        """
        if len(self.knn_n_neighbors_lineEdit.text()) > 0 or self.knn_grid_search_checkBox.isChecked():
            if (self.knn_n_neighbors_lineEdit.text()[0] == '0' or int(
                    self.knn_n_neighbors_lineEdit.text()) % 2 == 0) and self.knn_grid_search_checkBox.isChecked() == 0:
                QMessageBox.warning(self, "提示", "请输入有效参数")
            else:
                # 不同数据处理进行的不同操作
                if self.knn_process_comboBox.currentIndex() == 0:
                    self.model_data = self.processed_data
                elif self.knn_process_comboBox.currentIndex() == 1:
                    scaler = StandardScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                elif self.knn_process_comboBox.currentIndex() == 2:
                    scaler = MinMaxScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                # 划分数据并进行均衡化处理
                x_train_row, x_test, y_train_row, y_test = train_test_split(self.model_data, self.target,
                                                                            train_size=self.load_data_split_rate)
                x_train, y_train = self.equal_oprate(x_train_row, y_train_row)
                # 网格搜索执行的操作
                if self.knn_grid_search_checkBox.isChecked():
                    temp_model = KNeighborsClassifier()
                    para_grid = [{'n_neighbors': [k for k in range(3, 21, 2)], 'weights': ['uniform', 'distance'],
                                  'p': [i for i in range(5)]}]
                    model = GridSearchCV(temp_model, para_grid)
                    self.model_check_list[self.item_index] = True
                # 正常参数执行的操作
                else:
                    model = KNeighborsClassifier(n_neighbors=int(self.knn_n_neighbors_lineEdit.text()),
                                                 weights=self.knn_weights_select, p=self.knn_p_select)
                # 将模型相关参数保存
                self.model_batch_handle(1, model, x_train, x_test, y_train, y_test,
                                        self.knn_process_comboBox.currentIndex())
                self.model_list.item(self.item_index).model_list_inf_label.setText('未训练/已保存')  # 更新列表项的文字

    def tree_criterion_handle(self, i):
        """
        tree_criterion_combobox槽函数
        :param i:
        :return:
        """
        if i == 0:
            self.tree_criterion_select = 'gini'
        elif i == 1:
            self.tree_criterion_select = 'entropy'

    def tree_splitter_handle(self, i):
        """
        tree_splitter_combobox槽函数
        :param i:
        :return:
        """
        if i == 0:
            self.tree_splitter_select = 'best'
        elif i == 1:
            self.tree_splitter_select = 'random'

    def tree_model_save(self):
        """
        tree模型保存逻辑
        :return:
        """
        if len(self.tree_depth_lineEdit.text()) > 0 or self.tree_grid_search_checkBox.isChecked():
            if self.tree_depth_lineEdit.text()[0] == '0' and self.tree_grid_search_checkBox.isChecked() == 0:
                QMessageBox.warning(self, "提示", "请输入有效参数")
            else:
                # 不同数据处理进行的不同操作
                if self.tree_process_comboBox.currentIndex() == 0:
                    self.model_data = self.processed_data
                elif self.tree_process_comboBox.currentIndex() == 1:
                    scaler = StandardScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                elif self.tree_process_comboBox.currentIndex() == 2:
                    scaler = MinMaxScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                # 划分数据并进行均衡化处理
                x_train_row, x_test, y_train_row, y_test = train_test_split(self.model_data, self.target,
                                                                            train_size=self.load_data_split_rate)
                x_train, y_train = self.equal_oprate(x_train_row, y_train_row)
                # 网格搜索执行的操作
                if self.tree_grid_search_checkBox.isChecked():
                    temp_model = tree.DecisionTreeClassifier()
                    para_grid = [{'criterion': ['gini', 'entropy'], 'max_depth': [k for k in range(3, 10, 1)],
                                  'splitter': ['best', 'random']}]
                    model = GridSearchCV(temp_model, para_grid)
                    self.model_check_list[self.item_index] = True
                # 正常参数执行的操作
                else:
                    model = tree.DecisionTreeClassifier(criterion=self.tree_criterion_select,
                                                        max_depth=int(self.tree_depth_lineEdit.text()),
                                                        splitter=self.tree_splitter_select)
                # 将模型相关参数保存
                self.model_batch_handle(1, model, x_train, x_test, y_train, y_test,
                                        self.tree_process_comboBox.currentIndex())
                self.model_list.item(self.item_index).model_list_inf_label.setText('未训练/已保存')  # 更新列表项的文字

    def guass_mode_handle(self, i):
        """
        guass_mode_combobox被激活时逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.guass_multipara_label.clear()
            self.guass_multipara_lineEdit.setHidden(True)
        elif i == 1:
            self.guass_multipara_label.setText("alpha:")
            self.guass_multipara_lineEdit.setText('1.0')
            self.guass_multipara_lineEdit.setPlaceholderText('请输入大于0的浮点数')
            self.guass_multipara_lineEdit.setVisible(True)
        elif i == 2:
            self.guass_multipara_label.setText("binarize:")
            self.guass_multipara_lineEdit.setText('0.5')
            self.guass_multipara_lineEdit.setPlaceholderText('请输入0~1之间的浮点数')
            self.guass_multipara_lineEdit.setVisible(True)

    def guass_model_save(self):
        """
        guass模型保存逻辑
        :return:
        """
        guass_save_flag = False
        if self.guass_mode_comboBox.currentIndex() == 0:  # 高斯朴素贝叶斯
            # 创建高斯模型
            model = GaussianNB()
            guass_save_flag = True
        elif self.guass_mode_comboBox.currentIndex() == 1:  # 多项式朴素贝叶斯
            if self.guass_grid_search_checkBox.isChecked():
                # 网格搜索
                temp_model = MultinomialNB()
                para_grid = [{'alpha': [k / 10.0 for k in range(1, 20, 2)], 'force_alpha': [False, True],
                              'fit_prior': [False, True]}]
                model = GridSearchCV(temp_model, para_grid)
                self.model_check_list[self.item_index] = True
                guass_save_flag = True
            else:
                try:
                    alpha = float(self.guass_multipara_lineEdit.text())
                except Exception as e:
                    print(e)
                    QMessageBox.warning(self, "提示", "请输入有效参数")
                else:
                    if alpha > 0:
                        # 创建多项式模型
                        model = MultinomialNB(alpha=alpha)
                        guass_save_flag = True
                    else:
                        QMessageBox.warning(self, "提示", "请输入有效参数")
        elif self.guass_mode_comboBox.currentIndex() == 2:  # 伯努利朴素贝叶斯
            if self.guass_grid_search_checkBox.isChecked():
                # 网格搜索
                temp_model = BernoulliNB()
                para_grid = [{'alpha': [k / 10.0 for k in range(1, 10, 1)], 'force_alpha': [False, True],
                              'fit_prior': [False, True]}]
                model = GridSearchCV(temp_model, para_grid)
                self.model_check_list[self.item_index] = True
                guass_save_flag = True
            else:
                try:
                    binarize = float(self.guass_multipara_lineEdit.text())
                except Exception as e:
                    print(e)
                    QMessageBox.warning(self, "提示", "请输入有效参数")
                else:
                    if 0 < binarize < 1:
                        # 创建伯努利模型
                        model = BernoulliNB(binarize=binarize)
                        guass_save_flag = True
                    else:
                        QMessageBox.warning(self, "提示", "请输入有效参数")
        if guass_save_flag is True:
            # 不同数据处理进行的不同操作
            if self.guass_process_comboBox.currentIndex() == 0:
                self.model_data = self.processed_data
            elif self.guass_process_comboBox.currentIndex() == 1:
                scaler = StandardScaler()
                self.model_data = scaler.fit_transform(self.processed_data)
                self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
            elif self.guass_process_comboBox.currentIndex() == 2:
                scaler = MinMaxScaler()
                self.model_data = scaler.fit_transform(self.processed_data)
                self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
            # 多项式和伯努利需要强制二值化
            if self.guass_mode_comboBox.currentIndex() in [1, 2]:
                scaler = MinMaxScaler()
                self.model_data = scaler.fit_transform(self.model_data)
            # 划分数据并进行均衡化处理
            x_train_row, x_test, y_train_row, y_test = train_test_split(self.model_data, self.target,
                                                                        train_size=self.load_data_split_rate)
            x_train, y_train = self.equal_oprate(x_train_row, y_train_row)
            # 将模型相关参数保存
            self.model_batch_handle(1, model, x_train, x_test, y_train, y_test, self.guass_mode_comboBox.currentIndex())
            self.model_list.item(self.item_index).model_list_inf_label.setText('未训练/已保存')  # 更新列表项的文字

    def svm_kernel_handle(self, i):
        """
        svm_kernel_combobox被激活时的逻辑
        :param i:
        :return:
        """
        if i == 0:
            self.svm_kernel_select = 'rbf'
        elif i == 1:
            self.svm_kernel_select = 'linear'
        elif i == 2:
            self.svm_kernel_select = 'poly'
        elif i == 3:
            self.svm_kernel_select = 'sigmoid'

    def svm_model_save(self):
        """
        svm模型保存逻辑
        :return:
        """
        svm_flag = False
        if len(self.svm_c_lineEdit.text()) > 0 or self.svm_grid_search_checkBox.isChecked():
            # 网格搜索执行的操作
            if self.svm_grid_search_checkBox.isChecked():
                temp_model = svm.SVC()
                para_grid = [
                    {'kernel': ['poly'], 'C': [1e-3, 1e-2, 1e-1, 1, 10, 100, 1000], 'gamma': [1e-3, 1e-2, 1e-1, 1, 10],
                     'coef0': [1e-3, 1e-2, 1e-1, 1, 10], 'degree': np.linspace(1, 1, 10)},
                    {'kernel': ['sigmoid'], 'C': [1e-3, 1e-2, 1e-1, 1, 10, 100, 1000],
                     'gamma': [1e-3, 1e-2, 1e-1, 1, 10], 'coef0': [1e-3, 1e-2, 1e-1, 1, 10]},
                    {'kernel': ['rbf'], 'C': [1e-3, 1e-2, 1e-1, 1, 10, 100, 1000], 'gamma': [1e-3, 1e-2, 1e-1, 1, 10]},
                    {'kernel': ['linear'], 'C': [1e-3, 1e-2, 1e-1, 1, 10, 100, 1000]}]
                model = GridSearchCV(temp_model, para_grid)
                self.model_check_list[self.item_index] = True
                svm_flag = True
            else:
                try:
                    c = float(self.svm_c_lineEdit.text())
                except Exception as e:
                    print(e)
                    QMessageBox.warning(self, "提示", "请输入有效参数")
                # 正常参数执行的操作
                else:
                    if c > 0:
                        model = svm.SVC(kernel=self.svm_kernel_select, C=c)
                        svm_flag = True
                    else:
                        QMessageBox.warning(self, "提示", "请输入有效参数")
            if svm_flag is True:
                # 不同数据处理进行的不同操作
                if self.svm_process_comboBox.currentIndex() == 0:
                    self.model_data = self.processed_data
                elif self.svm_process_comboBox.currentIndex() == 1:
                    scaler = StandardScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                elif self.svm_process_comboBox.currentIndex() == 2:
                    scaler = MinMaxScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                # 划分数据并进行均衡化处理
                x_train_row, x_test, y_train_row, y_test = train_test_split(self.model_data, self.target,
                                                                            train_size=self.load_data_split_rate)
                x_train, y_train = self.equal_oprate(x_train_row, y_train_row)
                # 将模型相关参数保存
                self.model_batch_handle(1, model, x_train, x_test, y_train, y_test,
                                        self.svm_process_comboBox.currentIndex())
                self.model_list.item(self.item_index).model_list_inf_label.setText('未训练/已保存')  # 更新列表项的文字

    def forest_model_save(self):
        """
        forest模型保存逻辑
        :return:
        """
        if (len(self.forest_n_lineEdit.text()) > 0 and len(
                self.forest_depth_lineEdit.text()) > 0) or self.forest_grid_search_checkBox.isChecked():
            if (self.forest_n_lineEdit.text()[0] == '0' or self.tree_depth_lineEdit.text()[0] == '0') and self.forest_grid_search_checkBox.isChecked() == 0:
                QMessageBox.warning(self, "提示", "请输入有效参数")
            else:
                # 不同数据处理进行的不同操作
                if self.forest_process_comboBox.currentIndex() == 0:
                    self.model_data = self.processed_data
                elif self.forest_process_comboBox.currentIndex() == 1:
                    scaler = StandardScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                elif self.forest_process_comboBox.currentIndex() == 2:
                    scaler = MinMaxScaler()
                    self.model_data = scaler.fit_transform(self.processed_data)
                    self.model_data = pd.DataFrame(self.model_data, columns=list(self.processed_data))
                # 划分数据并进行均衡化处理
                x_train_row, x_test, y_train_row, y_test = train_test_split(self.model_data, self.target,
                                                                            train_size=self.load_data_split_rate)
                x_train, y_train = self.equal_oprate(x_train_row, y_train_row)
                # 网格搜索执行的操作
                if self.forest_grid_search_checkBox.isChecked():
                    temp_model = RandomForestClassifier()
                    para_grid = [{'n_estimators': [2000], 'max_depth': [3, 5, 8, 15, 25, 30, None], 'random_state': [0],
                                  'n_jobs': [-1]}]
                    model = GridSearchCV(temp_model, para_grid)
                    self.model_check_list[self.item_index] = True
                # 正常参数执行的操作
                else:
                    model = RandomForestClassifier(n_estimators=int(self.forest_n_lineEdit.text()),
                                                   max_depth=int(self.forest_depth_lineEdit.text()), random_state=0,
                                                   n_jobs=-1)
                # 将模型相关参数保存
                self.model_batch_handle(1, model, x_train, x_test, y_train, y_test,
                                        self.forest_process_comboBox.currentIndex())
                self.model_list.item(self.item_index).model_list_inf_label.setText('未训练/已保存')  # 更新列表项的文字

    def model_batch_handle(self, i, *args):
        """
        批量操作存储模型数据的list
        :return:
        """
        # 添加空项
        if i == 0:
            self.model_code_name_lists.append(None)
            self.model_code_categorical_lists.append(None)
            self.model_code_mode_lists.append(None)
            self.model_process_lists.append(None)
            self.trained_model_list.append(None)
            self.model_para_list.append(None)
            self.model_check_list.append(False)
            self.x_train_list.append(None)
            self.x_test_list.append(None)
            self.y_train_list.append(None)
            self.y_test_list.append(None)
        # 保存模型参数
        if i == 1:
            self.model_code_name_lists[self.item_index] = self.code_name_lists
            self.model_code_categorical_lists[self.item_index] = self.code_categorical_lists
            self.model_code_mode_lists[self.item_index] = self.code_mode_lists
            self.model_para_list[self.item_index] = args[0]
            self.x_train_list[self.item_index] = args[1]
            self.x_test_list[self.item_index] = args[2]
            self.y_train_list[self.item_index] = args[3]
            self.y_test_list[self.item_index] = args[4]
            self.model_process_lists[self.item_index] = args[5]
        # 删除模型
        if i == 2:
            self.model_code_name_lists.pop(self.item_index)
            self.model_code_categorical_lists.pop(self.item_index)
            self.model_code_mode_lists.pop(self.item_index)
            self.trained_model_list.pop(self.item_index)
            self.model_para_list.pop(self.item_index)
            self.model_check_list.pop(self.item_index)
            self.x_train_list.pop(self.item_index)
            self.x_test_list.pop(self.item_index)
            self.y_train_list.pop(self.item_index)
            self.y_test_list.pop(self.item_index)
            self.model_process_lists.pop(self.item_index)

    # 模型评估槽函数
    def model_assess_but_handle(self, action):
        """
        生成并显示评估图
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif len(self.trained_model_list) == 0:
            QMessageBox.warning(self, "提示", "请先创建模型")
        elif self.trained_model_list[self.item_index] is None:
            QMessageBox.warning(self, "提示", "该模型未训练，请先训练")
        else:
            self.action = action.data()
            if self.action == 'AUC' and len(self.labels) > 2:
                QMessageBox.warning(self, "提示", "标签超过两个的数据集无法生成AUC")
            elif self.action == 'confusion_matrix' and self.action in self.assess_graphic_list:
                QMessageBox.warning(self, "提示", "该评估图已存在")
            elif self.action == 'AUC' and self.action in self.assess_graphic_list:
                QMessageBox.warning(self, "提示", "该评估图已存在")
            else:
                # 添加并显示新页
                self.assess_page_total += 1
                self.assess_page_now = self.assess_page_total
                self.model_assess_select_stack.setCurrentIndex(self.assess_page_now if self.assess_page_now < 3 else 2)
                self.model_page_label.setText("共{}页/第{}页".format(self.assess_page_total + 1, self.assess_page_now + 1))
                self.model_assess_select_stack.setCurrentIndex(2)
                if self.assess_page_total == 2:
                    self.assess_graphic_list[0] = self.action
                elif self.assess_page_total == 3:
                    self.assess_graphic_list[1] = self.action
                # 画图并显示
                canvas = self.my_plot(self.action)
                graphicscene = QtWidgets.QGraphicsScene()  # 第三步，创建一个QGraphicsScene，因为加载的图形（FigureCanvas）不能直接放到graphicview控件中，必须先放到graphicScene，然后再把graphicscene放到graphicview中
                graphicscene.addWidget(canvas)  # 第四步，把图形放到QGraphicsScene中，注意：图形是作为一个QWidget放到QGraphicsScene中的
                self.graphic_view.setScene(graphicscene)  # 第五步，把QGraphicsScene放入QGraphicsView
                self.graphic_view.show()  # 最后，调用show方法呈现图形！

    def my_plot(self, action):
        """
        绘制相关图形
        :return:
        """
        if action == "confusion_matrix":
            figure = plt.figure(figsize=(6, 4), dpi=200)
            canvas = FigureCanvas(figure)
            cms = confusion_matrix(self.y_test_list[self.item_index],
                                   self.trained_model_list[self.item_index].predict(self.x_test_list[self.item_index]))
            sns.set_style('whitegrid')  # darkgrid, whitegrid, dark, white, ticks
            sns.heatmap(cms, annot=True, fmt="d", cmap="RdBu_r", linewidths=.5, linecolor="white",
                        cbar_kws={"orientation": "vertical"})  # RdBu_r,YlGnBu,horizontal
            plt.xlabel('Predict Label')
            plt.ylabel('Ture Label')
            plt.title('Confusion Matrix')
            canvas.draw()  # 这是关键
        elif action == "AUC":
            figure = plt.figure(figsize=(6, 4), dpi=200)
            canvas = FigureCanvas(figure)
            # AUC = roc_auc_score(self.y_test_list[self.item_index], self.trained_model_list[self.item_index].predict(self.x_test_list[self.item_index]))
            fpr, tpr, thersholds = roc_curve(self.y_train_list[self.item_index],
                                             self.trained_model_list[self.item_index].predict(
                                                 self.x_train_list[self.item_index]), pos_label=1)
            roc_auc = auc(fpr, tpr)
            plt.style.use("ggplot")
            plt.plot(fpr, tpr, 'skyblue', label='ROC (area = {0:.2f})'.format(roc_auc), lw=2)
            plt.plot(np.array([0, .2, .4, .6, .8, 1]), np.array([0, .2, .4, .6, .8, 1]), 'r--', label='Random guess',
                     lw=2)
            plt.fill_between(fpr, tpr, color="skyblue", alpha=0.3)
            plt.xlim([-0.05, 1.05])
            plt.ylim([-0.05, 1.05])
            plt.xlabel('False Positive Rate')
            plt.ylabel('True Positive Rate')
            plt.title('ROC Curve')
            plt.legend(loc="lower right")
            canvas.draw()  # 这是关键
        return canvas

    def graphic_edit_but_handle(self):
        """
        混淆矩阵单独显示
        :return:
        """
        plt.show()
        # 显示后需要重新绘制
        canvas = self.my_plot(self.action)
        graphicscene = QtWidgets.QGraphicsScene()
        graphicscene.addWidget(canvas)
        self.graphic_view.setScene(graphicscene)
        self.graphic_view.show()

    def model_trained_but_handle(self):
        """
        模型训练结果按钮逻辑
        :return:
        """
        if self.trained_model_list[self.item_index] is None:
            QMessageBox.warning(self, "提示", "模型还未训练")
        else:
            # 重新生成评估结果
            self.assess_data_generate()
            # 模型stack的模型选择satck的第1页，模型按钮stack的第1页
            self.total_stack.setCurrentIndex(2)
            self.model_page_select_stack.setCurrentIndex(1)
            self.model_page_but_stack.setCurrentIndex(1)
            # 页数重新初始化
            self.assess_page_now = 0
            self.assess_page_total = 1
            self.model_page_label.setText("共{}页/第{}页".format(self.assess_page_total + 1, self.assess_page_now + 1))
            self.model_assess_select_stack.setCurrentIndex(self.assess_page_now)

    def model_prepage_but_handle(self):
        """
        模型评估上一页按钮逻辑
        :return:
        """
        if self.assess_page_now <= 0:  # 页数不能小于0
            pass
        else:
            # 页数重新显示
            self.assess_page_now -= 1
            self.model_assess_select_stack.setCurrentIndex(self.assess_page_now)
            self.model_page_label.setText("共{}页/第{}页".format(self.assess_page_total + 1, self.assess_page_now + 1))
            # 在第三页时重新生成不同评估图像
            if self.assess_page_now == 2:
                if self.assess_graphic_list[0] == "confusion_matrix":
                    canvas = self.my_plot("confusion_matrix")
                elif self.assess_graphic_list[0] == "AUC":
                    canvas = self.my_plot("AUC")
                graphicscene = QtWidgets.QGraphicsScene()
                graphicscene.addWidget(canvas)
                self.graphic_view.setScene(graphicscene)
                self.graphic_view.show()

    def model_nextpage_but_handle(self):
        """
        模型评估下一页按钮逻辑
        :return:
        """
        if self.assess_page_now >= self.assess_page_total:  # 页数不能大于总页数
            pass
        else:
            # 页数重新显示
            self.assess_page_now += 1
            self.model_assess_select_stack.setCurrentIndex(self.assess_page_now if self.assess_page_now < 3 else 2)
            self.model_page_label.setText("共{}页/第{}页".format(self.assess_page_total + 1, self.assess_page_now + 1))
            # 在第三页时重新生成不同评估图像
            if self.assess_page_now == 2:
                if self.assess_graphic_list[0] == "confusion_matrix":
                    canvas = self.my_plot("confusion_matrix")
                elif self.assess_graphic_list[0] == "AUC":
                    canvas = self.my_plot("AUC")
                graphicscene = QtWidgets.QGraphicsScene()
                graphicscene.addWidget(canvas)
                self.graphic_view.setScene(graphicscene)
                self.graphic_view.show()
            # 在第四页时重新生成不同评估图像
            elif self.assess_page_now == 3:
                if self.assess_graphic_list[1] == "confusion_matrix":
                    canvas = self.my_plot("confusion_matrix")
                elif self.assess_graphic_list[1] == "AUC":
                    canvas = self.my_plot("AUC")
                graphicscene = QtWidgets.QGraphicsScene()
                graphicscene.addWidget(canvas)
                self.graphic_view.setScene(graphicscene)
                self.graphic_view.show()

    def assess_data_generate(self):
        """
        模型评估数据产生
        :return:
        """
        # 刷新准确率表格
        self.acc_model = QStandardItemModel()
        self.acc_model.clear()  # 二次刷新时先清除原先的数据
        self.acc_model.setHorizontalHeaderLabels(['准确率'])
        self.acc_model.setVerticalHeaderLabels(['训练集', '测试集'])
        train_score = accuracy_score(self.y_train_list[self.item_index],
                                     self.trained_model_list[self.item_index].predict(
                                         self.x_train_list[self.item_index]))
        test_score = accuracy_score(self.y_test_list[self.item_index],
                                    self.trained_model_list[self.item_index].predict(self.x_test_list[self.item_index]))
        self.acc_model.setItem(0, 0, QStandardItem(str(train_score)))
        self.acc_model.setItem(1, 0, QStandardItem(str(test_score)))
        self.acc_table.setModel(self.acc_model)
        # 刷新classification_report矩阵表格
        report = classification_report(self.y_train_list[self.item_index],
                                       self.trained_model_list[self.item_index].predict(
                                           self.x_train_list[self.item_index]), labels=self.labels, output_dict=True)
        df = pd.DataFrame(report).transpose()
        self.martix_data = df
        self.martix_model = QStandardItemModel()
        self.martix_model.clear()  # 二次刷新时先清除原先的数据
        self.martix_model.setHorizontalHeaderLabels(list(df))
        self.martix_model.setVerticalHeaderLabels(df.index)
        for i in range(df.shape[0]):
            for j in range(df.shape[1]):
                item = QStandardItem(str(df.iloc[i, j]))
                self.martix_model.setItem(i, j, item)
        self.martix_table.setModel(self.martix_model)

    def model_export_but_handle(self):
        """
        模型导出按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif len(self.trained_model_list) == 0:
            QMessageBox.warning(self, "提示", "请先创建模型")
        elif self.trained_model_list[self.item_index] is None:
            QMessageBox.warning(self, "提示", "该模型未训练，请先训练")
        else:
            path, _ = QFileDialog.getSaveFileName(self, '保存模型', './', '*.kmodel')
            joblib.dump(filename=path, value=self.trained_model_list[self.item_index])

    def model_predict_but_handle(self):
        """
        模型预测按钮逻辑
        :return:
        """
        if self.load_data_flag is False:
            QMessageBox.warning(self, "提示", "请先导入数据")
        elif len(self.trained_model_list) == 0:
            QMessageBox.warning(self, "提示", "请先创建模型")
        elif self.trained_model_list[self.item_index] is None:
            QMessageBox.warning(self, "提示", "该模型未训练，请先训练")
        else:
            filename, _ = QFileDialog.getOpenFileName(self, '选择文件', '', '*.csv;;*.xlsx')
            if not filename:
                pass  # 防止没有选择直接关闭导致程序崩溃
            else:
                try:
                    # 判断文件类型
                    if filename.split('.')[-1] == 'csv':
                        copyfile(filename, './temp/predict_data_temp.csv')
                        self.predict_row_data = pd.read_csv('./temp/predict_data_temp.csv')
                    elif filename.split('.')[-1] == 'xlsx':
                        copyfile(filename, './temp/predict_data_temp.xlsx')
                        self.predict_row_data = pd.read_excel('./temp/predict_data_temp.xlsx')
                except IOError as e:
                    print("Unable to copy file. %s" % e)
                    exit(1)
                # 选择相同的列
                colName = list(self.x_train_list[self.item_index])
                print(colName)
                self.predict_row_data = pd.DataFrame(self.predict_row_data, columns=colName)
                # 编码
                for name in colName:
                    if name in self.model_code_name_lists[self.item_index]:  # 判断是否由需要编码的列
                        i = self.model_code_name_lists[self.item_index].index(name)
                        if self.model_code_mode_lists[self.item_index][i] == 0:  # 从0开始编码
                            categorical = pd.Categorical(self.predict_row_data[name],
                                                         self.model_code_categorical_lists[self.item_index][i])
                            self.predict_row_data[name] = categorical.codes
                        elif self.model_code_mode_lists[self.item_index][i] == 1:  # 从1开始编码
                            categorical = pd.Categorical(self.predict_row_data[name],
                                                         self.model_code_categorical_lists[self.item_index][i])
                            self.predict_row_data[name] = categorical.codes + 1
                # 预处理
                if self.model_process_lists[self.item_index] == 0:
                    self.predict_data = self.predict_row_data
                elif self.model_process_lists[self.item_index] == 1:
                    scaler = StandardScaler()
                    self.predict_data = scaler.fit_transform(self.predict_row_data)
                    self.predict_data = pd.DataFrame(self.predict_data, columns=colName)
                elif self.model_process_lists[self.item_index] == 2:
                    scaler = MinMaxScaler()
                    self.predict_data = scaler.fit_transform(self.predict_row_data)
                    self.predict_data = pd.DataFrame(self.predict_data, columns=colName)
                # 预测
                try:
                    predict = self.trained_model_list[self.item_index].predict(self.predict_data)
                except Exception as e:
                    print(e)
                    QMessageBox.warning(self, "提示", "导入的数据不符合规范，请重新导入")
                else:
                    self.predict_data.insert(self.predict_data.shape[1], '预测', predict)
                    # 创建一个标准模型
                    self.predict_model = QStandardItemModel()
                    self.predict_model.clear()  # 二次加载时清空原来的
                    # 设置表头标签
                    self.predict_model.setHorizontalHeaderLabels(list(self.predict_data))
                    # 提交项
                    for i in range(self.predict_data.shape[0]):
                        temp_list = []
                        for j in range(self.predict_data.shape[1]):
                            temp_list.append(QStandardItem(str(self.predict_data.iloc[i, j])))
                        self.predict_model.appendRow(temp_list)
                    self.model_predict_table.setModel(self.predict_model)
                    self.total_stack.setCurrentIndex(2)
                    self.model_page_select_stack.setCurrentIndex(1)
                    self.model_assess_select_stack.setCurrentIndex(3)
                    self.model_page_but_stack.setCurrentIndex(2)

    # 数据预处理表格槽函数
    def process_table_menu(self):
        """
        加载数据表格右键的自定义菜单
        :return:
        """
        self.process_table.contextMenu = QMenu()  # 初始化tableView菜单
        action = self.process_table.contextMenu.addAction(u"保存表格")
        action.triggered.connect(self.save_process_table)

        self.process_table.contextMenu.popup(QCursor.pos())  # 根据鼠标坐标显示右击菜单
        self.process_table.contextMenu.show()

    def save_process_table(self):
        """
        保存表格逻辑
        :return:
        """
        if self.process_table_flag == 0:
            QMessageBox.warning(self, "提示", "该表格暂不支持导出")
        elif self.process_table_flag == 1:
            path, _ = QFileDialog.getSaveFileName(self, '保存表格', './', '*.csv')
            self.code_after_data.to_csv(path)
        elif self.process_table_flag == 2:
            path, _ = QFileDialog.getSaveFileName(self, '保存表格', './', '*.csv')
            self.select_feature_data.to_csv(path)
        elif self.process_table_flag == 3:
            path, _ = QFileDialog.getSaveFileName(self, '保存表格', './', '*.csv')
            self.pca_data.to_csv(path)

    # 模型评估表格槽函数
    def martix_table_menu(self):
        """
        加载数据表格右键的自定义菜单
        :return:
        """
        self.martix_table.contextMenu = QMenu()  # 初始化tableView菜单
        action = self.martix_table.contextMenu.addAction(u"保存表格")
        action.triggered.connect(self.save_martix_table)

        self.martix_table.contextMenu.popup(QCursor.pos())  # 根据鼠标坐标显示右击菜单
        self.martix_table.contextMenu.show()

    def save_martix_table(self):
        """
        保存表格逻辑
        :return:
        """
        path, _ = QFileDialog.getSaveFileName(self, '保存表格', './', '*.csv')
        self.martix_data.to_csv(path)

    # 数据导入界面不常用的槽函数
    def load_data_select_spilt_combobox_handle(self, i):
        """
        训练集、验证集分割比例选择函数
        :param i:
        :return:
        """
        if i == 0:
            self.load_data_split_rate = 0.6
        elif i == 1:
            self.load_data_split_rate = 0.7
        elif i == 2:
            self.load_data_split_rate = 0.8
        elif i == 3:
            self.load_data_split_rate = 0.9
        # self.load_data_split_rate = 0.6 + i*0.1

    def double_click(self):
        """
        表格双击事件
        :return:
        """
        if self.load_data_table_select_mode.hasSelection():  # 如果被选择
            self.selected_index = self.load_data_table_select_mode.selectedIndexes()[0]  # 获取item的编号
            self.data_change_flag = 1  # 更改标志位置1

    def keyReleaseEvent(self, event):
        """
        按键事件，用来检测表格数据是否被修改
        :param event: 释放按键事件
        :return:
        """
        if event.key() == 16777220:  # 释放确定键时
            if self.data_change_flag == 1:
                self.data_change_flag = 0
                # 修改ori_data相应的值
                if type(self.ori_data.iloc[self.selected_index.row(), self.selected_index.column()]) == int:
                    self.ori_data.iloc[self.selected_index.row(), self.selected_index.column()] = \
                        int(self.load_data_model.index(self.selected_index.row(), self.selected_index.column()).data())
                elif type(self.ori_data.iloc[self.selected_index.row(), self.selected_index.column()]) == np.float64:
                    self.ori_data.iloc[self.selected_index.row(), self.selected_index.column()] = \
                        float(
                            self.load_data_model.index(self.selected_index.row(), self.selected_index.column()).data())
                # print(self.data_model.index(self.selected_index.row(),  self.selected_index.column()).data(), self.selected_index.row(), self.selected_index.column())

    def load_data_table_menu(self):
        """
        加载数据表格右键的自定义菜单
        :return:
        """
        self.load_data_table.contextMenu = QMenu()  # 初始化tableView菜单
        action1 = self.load_data_table.contextMenu.addAction(u"删除整行")  # 添加菜单内容
        action2 = self.load_data_table.contextMenu.addAction(u"删除整列")
        action3 = self.load_data_table.contextMenu.addAction(u"保存表格")

        action1.triggered.connect(self.delete_row)  # 菜单点击触发槽函数
        action2.triggered.connect(self.delete_col)
        action3.triggered.connect(self.save_load_data_table)

        self.load_data_table.contextMenu.popup(QCursor.pos())  # 根据鼠标坐标显示右击菜单
        self.load_data_table.contextMenu.show()

    def delete_row(self):
        """
        删除加载数据表的整行
        :return:
        """
        if self.load_data_table_select_mode.hasSelection():
            selected_index = self.load_data_table_select_mode.selectedIndexes()[0]
            self.load_data_model.removeRow(selected_index.row())
            # 在ori_data上删除相应数据
            self.ori_data = self.ori_data.drop(self.ori_data.index[[selected_index.column()]])

    def delete_col(self):
        """
        删除加载数据表的整列
        :return:
        """
        if self.load_data_table_select_mode.hasSelection():
            selected_index = self.load_data_table_select_mode.selectedIndexes()[0]
            self.load_data_model.removeColumn(selected_index.column())
            # 在ori_data上删除相应数据
            self.ori_data = self.ori_data.drop(self.ori_data.columns[[selected_index.column()]], axis=1)
            # 重置数据导入界面的combobox
            self.load_data_select_target_combobox.clear()
            for i in range(self.ori_data.shape[1]):
                self.load_data_select_target_combobox.addItem(list(self.ori_data)[i])

    def save_load_data_table(self):
        """
        保存表格逻辑
        :return:
        """
        path, _ = QFileDialog.getSaveFileName(self, '保存表格', './', '*.csv')
        self.ori_data.to_csv(path)
